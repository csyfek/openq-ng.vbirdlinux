<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-TW" lang="zh-TW"><!-- InstanceBegin template="/Templates/tp_basic.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="Author" content="VBird, 鳥哥" />
	<meta name="Description" content="Linux 最重要是基礎學習，在這個單元中，我們介紹很多 Linux 基礎觀念！" />
    <link href="../styles/default.css" rel="stylesheet" type="text/css" />
<!-- InstanceBeginEditable name="doctitle" -->
    <title>鳥哥的 Linux 私房菜 -- 基礎學習篇</title>
    <!-- InstanceEndEditable -->
    <!-- InstanceBeginEditable name="head" -->
    <!-- InstanceEndEditable -->
</head>
<body style="margin:0; padding:0">
<center>


<!-- 這裡是關於頁首按鈕處的按鈕程式 -->
<div style="text-align:center">
<span style="font-weight:bolder; color:#3333FF"><span class="text_head0">鳥哥的<span class="text_head_en"> 
	Linux </span>私房菜</span></span><br />
<span style="color:#000080">為取得較佳瀏覽結果，請愛用 <a href="http://moztw.org" target="_blank">firefox</a>
	瀏覽本網頁</span><br />

<a href="http://linux.vbird.org" target="_top">鳥哥的 Linux 私房菜館</a> | 
<a href="../index.htm">目錄</a> | 
<a href="index.htm">Linux 基礎文件</a> | 
<a href="../linux_server/index.htm">Linux 架站文件</a> | 
<a href="../linux_enterprise/index.htm">Linux 企業運用</a> | 
<a href="../linux_security/index.htm">安全管理</a> | 
<a href="http://phorum.vbird.org">新手討論</a> | 
<br />
</div>


<table summary="本文內容的排版" style="background-color: #fff;" border="0" cellspacing="0" cellpadding="0" class="wrap">
<tr><td style="width:16px; height:16px; font-size:6px;">　</td>
    <td style="width:718px; height:16px; font-size:6px;">　</td>
    <td style="width:16px; height:16px; font-size:6px;">　</td></tr>
<tr><td style="width:16px; font-size:6px;">　</td>
  
  <!-- InstanceBeginEditable name="content" -->
<td width="718">

<!-- 本文的檔頭部分 -->
<div style="text-align:center">
    <span class="text_head0">第七章、<span class="text_head_en">Linux </span>檔案與目錄管理</span><br />
</div>
<div style="text-align:right">
  <span class="text_history">最近更新日期：2009/08/26</span>
</div>

<!-- 本文的檔頭部分 -->
<table class="head1" summary="排版：文章檔頭的說明"><tr><td class="head1">
	在第六章我們認識了Linux系統下的檔案權限概念以及目錄的配置說明。
	在這個章節當中，我們就直接來進一步的操作與管理檔案與目錄吧！包括在不同的目錄間變換、
	建立與刪除目錄、建立與刪除檔案，還有尋找檔案、查閱檔案內容等等，
	都會在這個章節作個簡單的介紹啊！
</td></tr></table><br />

<!-- 本文的連結區部分 -->

<div class="block1">
<span class="text_h1">
1. <a href="#dir">目錄與路徑</a><br />
	<span class="text_h2">
	　　1.1 <a href="#dir_pathway">相對路徑與絕對路徑</a><br />
	　　1.2 <a href="#dir_opdir">目錄的相關操作</a>： <a href="#cd">cd</a>, <a href="#pwd">pwd</a>, 
		<a href="#mkdir">mkdir</a>, <a href="#rmdir">rmdir</a><br />

	　　1.3 <a href="#dir_path">關於執行檔路徑的變數： $PATH</a><br />
	</span>
2. <a href="#file_dir_manage">檔案與目錄管理</a><br />
	<span class="text_h2">
	　　2.1 <a href="#ls">檔案與目錄的檢視： ls</a><br />
	　　2.2 <a href="#cprmmv">複製、刪除與移動</a>： <a href="#cp">cp</a>, <a href="#rm">rm</a>, <a href="#mv">mv</a><br />

	　　2.3 <a href="#dir_name">取得路徑的檔案名稱與目錄名稱</a><br />
	</span>
3. <a href="#file_content">檔案內容查閱：</a><br />
	<span class="text_h2">
	　　3.1 <a href="#file_content_1">直接檢視檔案內容</a>： <a href="#cat">cat</a>, 
		<a href="#tac">tac</a>, <a href="#nl">nl</a><br />

	　　3.2 <a href="#file_content_2">可翻頁檢視</a>： <a href="#more">more</a>, <a href="#less">less</a><br />
	　　3.3 <a href="#file_content_3">資料擷取</a>： <a href="#head">head</a>, <a href="#tail">tail</a><br />
	　　3.4 <a href="#od">非純文字檔： od</a><br />

	　　3.5 <a href="#touch">修改檔案時間與建置新檔： touch</a><br />
	</span>
4. <a href="#fileperm">檔案與目錄的預設權限與隱藏權限</a><br />
	<span class="text_h2">
	　　4.1 <a href="#umask">檔案預設權限：umask</a><br />
	　　4.2 <a href="#attr">檔案隱藏屬性：</a> <a href="#chattr">chattr</a>, <a href="#lsattr">lsattr</a><br />

	　　4.4 <a href="#suid_sgid_sbit">檔案特殊權限</a>：<a href="#suid">SUID</a>, <a href="#sgid">SGID</a>,
		<a href="#sbit">SBIT</a>, <a href="#suid_set">權限設定</a><br />
	　　4.3 <a href="#file">觀察檔案類型：file</a><br />
	</span>

5. <a href="#file_find">指令與檔案的搜尋：</a><br />
	<span class="text_h2">
	　　5.1 <a href="#file_find_cmd">指令檔名的搜尋：</a><a href="#which">which</a><br />
	　　5.2 <a href="#file_find_file">檔案檔名的搜尋：</a><a href="#whereis">whereis</a>,
		<a href="#locate">locate</a>, <a href="#find">find</a><br />

	</span>
6. <a href="#import">極重要！權限與指令間的關係：</a><br />
7. <a href="#hint">重點回顧</a><br />
8. <a href="#ex">本章習題</a><br />
9. <a href="#reference">參考資料與延伸閱讀</a><br />
<span class="text_h2">
10. <a href="http://phorum.vbird.org/viewtopic.php?t=23879"
    target="_blank">針對本文的建議：http://phorum.vbird.org/viewtopic.php?t=23879</a>

</span>
</span>
</div>


<!-- 本文的正式部分 -->
<hr /><a name="dir"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">目錄與路徑：</span><br />
<div class="block1">
	<p>由第六章<a href="/linux_basic/0210filepermission.php">Linux的檔案權限與目錄配置</a>中透過FHS瞭解了Linux的『樹狀目錄』概念之後，
	接下來就得要實際的來搞定一些基本的路徑問題了！這些目錄的問題當中，最重要的莫過於第六章也談過的<a
	href="/linux_basic/0210filepermission.php#dir_path">『絕對路徑』與『相對路徑』</a>的意義啦！
	絕對/相對路徑的寫法並不相同，要特別注意。此外，當妳下達指令時，該指令是透過什麼功能來取得的？
	這與PATH這個變數有關呢！底下就讓我們來談談囉！<br /><br /></p>

	<hr /><a name="dir_pathway"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">相對路徑與絕對路徑：</span>
	<div class="block2">
		<p>在開始目錄的切換之前，你必須要先瞭解一下所謂的『<span class="text_import2">路徑(PATH)</span>』，
		有趣的是：什麼是『<span class="text_import2">相對路徑</span>』與『<span class="text_import2">絕對路徑</span>』？
		雖然前一章已經稍微針對這個議題提過一次，不過，這裡不厭其煩的再次的強調一下！</p>

		<ul>

		<li><span class="text_import2">絕對路徑</span>：路徑的寫法『<span class="text_import2">一定由根目錄
			/ 寫起</span>』，例如： /usr/share/doc 這個目錄。</li>
		<li><span class="text_import2">相對路徑</span>：路徑的寫法『<span class="text_import2">不是由
			/ 寫起</span>』，例如由 /usr/share/doc 要到 /usr/share/man 底下時，可以寫成：
			『<span style="font-family:'細明體'">cd 
			../man</span>』這就是相對路徑的寫法啦！相對路徑意指『相對於目前工作目錄的路徑！』</li></ul><br />

		<hr /><ul class="list1"><li class="text_import1">相對路徑的用途</li></ul>

		<p>那麼相對路徑與絕對路徑有什麼了不起呀？喝！那可真的是了不起了！假設你寫了一個軟體，
		這個軟體共需要三個目錄，分別是 etc, bin, man 這三個目錄，然而由於不同的人喜歡安裝在不同的目錄之下，
		假設甲安裝的目錄是 /usr/local/packages/etc, /usr/local/packages/bin 及 /usr/local/packages/man 
		，不過乙卻喜歡安裝在 /home/packages/etc, /home/packages/bin, /home/packages/man 
		這三個目錄中，請問如果需要用到絕對路徑的話，那麼是否很麻煩呢？是的！
		如此一來每個目錄下的東西就很難對應的起來！這個時候相對路徑的寫法就顯的特別的重要了！</p>

		<p>此外，如果你跟鳥哥一樣，喜歡將路徑的名字寫的很長，好讓自己知道那個目錄是在幹什麼的，例如：
		/cluster/raid/output/taiwan2006/smoke 這個目錄，而另一個目錄在 
		/cluster/raid/output/taiwan2006/cctm ，那麼我從第一個要到第二個目錄去的話，怎麼寫比較方便？
		當然是『 <span style="font-family:'細明體'">cd ../cctm</span> 』比較方便囉！對吧！<br /><br /></p>

		<hr /><ul class="list1"><li class="text_import1">絕對路徑的用途</li></ul>
		<p>但是對於檔名的正確性來說，『<span class="text_import2">絕對路徑的正確度要比較好～</span>』。
		一般來說，鳥哥會建議你，如果是在寫程式 (shell scripts) 來管理系統的條件下，務必使用絕對路徑的寫法。
		怎麼說呢？因為絕對路徑的寫法雖然比較麻煩，但是可以肯定這個寫法絕對不會有問題。
		如果使用相對路徑在程式當中，則可能由於你執行的工作環境不同，導致一些問題的發生。
		這個問題在<a href="/linux_basic/0430cron.php">工作排程(at, cron, 第十六章)</a>當中尤其重要！這個現象我們在<a 
		href="/linux_basic/0340bashshell-scripts.php">十三章、shell script</a>時，會再次的提醒你喔！ ^_^</p>

	</div>

	<hr /><a name="dir_opdir"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">目錄的相關操作：</span>
	<div class="block2">
		<p>我們之前稍微提到變換目錄的指令是cd，還有哪些可以進行目錄操作的指令呢？
		例如建立目錄啊、刪除目錄之類的～還有，得要先知道的，就是有哪些比較特殊的目錄呢？
		舉例來說，底下這些就是比較特殊的目錄，得要用力的記下來才行：</p>

<table class="term"><tr><td class="term"><pre>
<span class="term_write">.         代表此層目錄
..        代表上一層目錄
-         代表前一個工作目錄
~         代表『目前使用者身份』所在的家目錄
~account  代表 account 這個使用者的家目錄(account是個帳號名稱)</span>
</pre></td></tr></table>

		<p>需要特別注意的是：<span class="text_import2">在所有目錄底下都會存在的兩個目錄，分別是『.』與『..』</span>
		分別代表此層與上層目錄的意思。那麼來思考一下底下這個例題：</p>

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">
請問在Linux底下，根目錄下有沒有上層目錄(..)存在？
</div>
答：<div class="block2">
若使用『 ls -al / 』去查詢，可以看到根目錄下確實存在 . 與 .. 兩個目錄，再仔細的查閱，
可發現這兩個目錄的屬性與權限完全一致，這代表<span class="text_import2">根目錄的上一層(..)與根目錄自己(.)是同一個目錄。</span>

</div>
</td></tr></table>

		<p>底下我們就來談一談幾個常見的處理目錄的指令吧：</p>
		<ul class="text_import2">
		<li>cd：變換目錄</li>
		<li>pwd：顯示目前的目錄</li>
		<li>mkdir：建立一個新的目錄</li>

		<li>rmdir：刪除一個空的目錄</li></ul><br />

		<a name="cd"></a>
		<hr /><ul class="list1"><li class="text_import1">cd (變換目錄)</li></ul>
		<p>我們知道vbird這個使用者的家目錄是/home/vbird/，而root家目錄則是/root/，假設我以root身份在 
		Linux系統中，那麼簡單的說明一下這幾個特殊的目錄的意義是：</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">cd [相對路徑或絕對路徑]</span>

<span class="term_say"># 最重要的就是目錄的絕對路徑與相對路徑，還有一些特殊目錄的符號囉！</span>
[root@www ~]# <span class="term_command">cd ~vbird</span>
<span class="term_say"># 代表去到 vbird 這個使用者的家目錄，亦即 /home/vbird</span>
[root@www vbird]# <span class="term_command">cd ~</span>
<span class="term_say"># 表示回到自己的家目錄，亦即是 /root 這個目錄</span>
[root@www ~]# <span class="term_command">cd</span>
<span class="term_say"># 沒有加上任何路徑，也還是代表回到自己家目錄的意思喔！</span>

[root@www ~]# <span class="term_command">cd ..</span>
<span class="term_say"># 表示去到目前的上層目錄，亦即是 /root 的上層目錄的意思；</span>
[root@www /]# <span class="term_command">cd -</span>
<span class="term_say"># 表示回到剛剛的那個目錄，也就是 /root 囉～</span>
[root@www ~]# <span class="term_command">cd /var/spool/mail</span>
<span class="term_say"># 這個就是絕對路徑的寫法！直接指定要去的完整路徑名稱！</span>
[root@www mail]# <span class="term_command">cd ../mqueue</span>

<span class="term_say"># 這個是相對路徑的寫法，我們由/var/spool/mail 去到/var/spool/mqueue 就這樣寫！</span>
</pre></td></tr></table>

		<p>cd是Change Directory的縮寫，這是用來變換工作目錄的指令。注意，目錄名稱與cd指令之間存在一個空格。
		一登入Linux系統後，root會在root的家目錄！那回到上一層目錄可以用『 cd .. 』。
		利用相對路徑的寫法必須要確認你目前的路徑才能正確的去到想要去的目錄。例如上表當中最後一個例子，
		你必須要確認你是在/var/spool/mail當中，並且知道在/var/spool當中有個mqueue的目錄才行啊～
		這樣才能使用cd ../mqueue去到正確的目錄說，否則就要直接輸入cd /var/spool/mqueue囉～</p>

		<p>其實，我們的提示字元，亦即那個 [root@www ~]# 當中，就已經有指出目前的目錄了，
		剛登入時會到自己的家目錄，而家目錄還有一個代碼，那就是『 ~ 』符號！
		例如上面的例子可以發現，使用『 cd ~ 』可以回到個人的家目錄裡頭去呢！
		另外，針對 cd 的使用方法，如果僅輸入 cd 時，代表的就是『 cd ~ 』的意思喔～
		亦即是會回到自己的家目錄啦！而那個『 cd - 』比較難以理解，請自行多做幾次練習，
		就會比較明白了。</p>

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tr><td><b>Tips:</b><br /><span style="color : #009000"><font size="-1">		還是要一再地提醒，我們的 Linux 的預設指令列模式 (bash shell) 具有檔案補齊功能，
		你要常常利用 [tab] 按鍵來達成你的目錄完整性啊！這可是個好習慣啊～
		可以避免你按錯鍵盤輸入錯字說～ ^_^
		</font></span></td><td><img src="/images/vbird_face.gif" alt="鳥哥的圖示" title="鳥哥的圖示" /></td></tr></table></div>

		<a name="pwd"></a>
		<hr /><ul class="list1"><li class="text_import1">pwd (顯示目前所在的目錄)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">pwd [-P]</span>
<span class="term_say">選項與參數：
-P  ：顯示出確實的路徑，而非使用連結 (link) 路徑。</span>

<span class="term_hd">範例：單純顯示出目前的工作目錄：</span>
[root@www ~]# <span class="term_command">pwd</span>

/root   <span class="term_note">&lt;== 顯示出目錄啦～</span>

<span class="term_hd">範例：顯示出實際的工作目錄，而非連結檔本身的目錄名而已</span>
[root@www ~]# <span class="term_command">cd /var/mail</span>   <span class="term_note">&lt;==注意，/var/mail是一個連結檔</span>
[root@www mail]# <span class="term_command">pwd</span>
/var/mail         <span class="term_note">&lt;==列出目前的工作目錄</span>

[root@www mail]# <span class="term_command">pwd -P</span>
/var/spool/mail   <span class="term_note">&lt;==怎麼回事？有沒有加 -P 差很多～</span>
[root@www mail]# <span class="term_command">ls -ld /var/mail</span>
<span class="term_write">lrwxrwxrwx</span> 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail
<span class="term_say"># 看到這裡應該知道為啥了吧？因為 /var/mail 是連結檔，連結到 /var/spool/mail 
# 所以，加上 pwd -P 的選項後，會不以連結檔的資料顯示，而是顯示正確的完整路徑啊！</span>
</pre></td></tr></table>

		<p>pwd是Print Working Directory的縮寫，也就是顯示目前所在目錄的指令，
		例如在上個表格最後的目錄是/var/mail這個目錄，但是提示字元僅顯示mail，
		如果你想要知道目前所在的目錄，可以輸入pwd即可。此外，由於很多的套件所使用的目錄名稱都相同，例如 
		/usr/local/etc還有/etc，但是通常Linux僅列出最後面那一個目錄而已，這個時候你就可以使用pwd 
		來知道你的所在目錄囉！免得搞錯目錄，結果...</p>

		<p>其實有趣的是那個 -P 的選項啦！他可以讓我們取得正確的目錄名稱，而不是以連結檔的路徑來顯示的。
		如果你使用的是CentOS 5.x的話，剛剛好/var/mail是/var/spool/mail的連結檔，
		所以，透過到/var/mail下達pwd -P就能夠知道這個選項的意義囉～ ^_^<br /><br /></p>

		<a name="mkdir"></a>
		<hr /><ul class="list1"><li class="text_import1">mkdir (建立新目錄)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">mkdir [-mp] 目錄名稱</span>

<span class="term_say">選項與參數：
-m ：設定檔案的權限喔！直接設定，不需要看預設權限 (umask) 的臉色～
-p ：幫助你直接將所需要的目錄(包含上層目錄)遞迴建立起來！</span>

<span class="term_hd">範例：請到/tmp底下嘗試建立數個新目錄看看：</span>
[root@www ~]# <span class="term_command">cd /tmp</span>
[root@www tmp]# <span class="term_command">mkdir test</span>    <span class="term_note">&lt;==建立一名為 test 的新目錄</span>
[root@www tmp]# <span class="term_command">mkdir test1/test2/test3/test4</span>
mkdir: cannot create directory `test1/test2/test3/test4': 
No such file or directory       <span class="term_note">&lt;== 沒辦法直接建立此目錄啊！</span>

[root@www tmp]# <span class="term_command">mkdir -p test1/test2/test3/test4</span>
<span class="term_say"># 加了這個 -p 的選項，可以自行幫你建立多層目錄！</span>

<span class="term_hd">範例：建立權限為rwx--x--x的目錄</span>
[root@www tmp]# <span class="term_command">mkdir -m 711 test2</span>
[root@www tmp]# <span class="term_command">ls -l</span>
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
<span class="term_write">drwx--x--x</span>  2 root  root 4096 Jul 18 12:54 test2

<span class="term_say"># 仔細看上面的權限部分，如果沒有加上 -m 來強制設定屬性，系統會使用預設屬性。
# 那麼你的預設屬性為何？這要透過底下介紹的 <a href="#umask"><span class="term_say" style="text-decoration: underline;">umask</span></a> 才能瞭解喔！ ^_^</span>
</pre></td></tr></table>

		<p>如果想要建立新的目錄的話，那麼就使用mkdir (make directory)吧！ 不過，在預設的情況下，
		<span class="text_import2">你所需要的目錄得一層一層的建立才行</span>！例如：假如你要建立一個目錄為 
		/home/bird/testing/test1，那麼首先必須要有 /home 然後 /home/bird ，再來 /home/bird/testing 
		都必須要存在，才可以建立 /home/bird/testing/test1 這個目錄！假如沒有 /home/bird/testing 
		時，就沒有辦法建立 test1 的目錄囉！</p>

		<p>不過，現在有個更簡單有效的方法啦！那就是加上 -p 這個選項喔！你可以直接下達：『 <span 
		class="text_import2">mkdir -p /home/bird/testing/test1</span> 』
		則系統會自動的幫你將 /home, /home/bird, /home/bird/testing 依序的建立起目錄！並且，
		<span class="text_import2">如果該目錄本來就已經存在時，系統也不會顯示錯誤訊息喔</span>！挺快樂的吧！ ^_^。
		不過鳥哥不建議常用-p這個選項，因為擔心如果妳打錯字，那麼目錄名稱就會變的亂七八糟的！</p>

		<p>另外，有個地方你必須要先有概念，那就是『預設權限』的地方。我們可以利用 -m 來強制給予一個新的目錄相關的權限，
		例如上表當中，我們給予 -m 711 來給予新的目錄 drwx--x--x 的權限。不過，如果沒有給予 -m 選項時，
		那麼預設的新建目錄權限又是什麼呢？這個跟 <a href="#umask">umask</a> 有關，我們在本章後頭會加以介紹的。<br /><br /></p>

		<a name="rmdir"></a>
		<hr /><ul class="list1"><li class="text_import1">rmdir (刪除『空』的目錄)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">rmdir [-p] 目錄名稱</span>

<span class="term_say">選項與參數：
-p ：連同上層『空的』目錄也一起刪除</span>

<span class="term_hd">範例：將於mkdir範例中建立的目錄(/tmp底下)刪除掉！</span>
[root@www tmp]# <span class="term_command">ls -l</span>   <span class="term_note">&lt;==看看有多少目錄存在？</span>
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
[root@www tmp]# <span class="term_command">rmdir test </span>  <span class="term_note">&lt;==可直接刪除掉，沒問題</span>
[root@www tmp]# <span class="term_command">rmdir test1</span>  <span class="term_note">&lt;==因為尚有內容，所以無法刪除！</span>

rmdir: `test1': Directory not empty
[root@www tmp]# <span class="term_command">rmdir -p test1/test2/test3/test4</span>
[root@www tmp]# <span class="term_command">ls -l      </span>  <span class="term_note">&lt;==您看看，底下的輸出中test與test1不見了！</span>
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
<span class="term_say"># 瞧！利用 -p 這個選項，立刻就可以將 test1/test2/test3/test4 一次刪除～
# 不過要注意的是，這個 rmdir 僅能『刪除空的目錄』喔！</span>
</pre></td></tr></table>

		<p>如果想要刪除舊有的目錄時，就使用rmdir吧！例如將剛剛建立的test殺掉，使用『 
		rmdir test 』即可！請注意呦！目錄需要一層一層的刪除才行！而且<span 
		class="text_import2">被刪除的目錄裡面必定不能存在其他的目錄或檔案！</span>

		這也是所謂的空的目錄(empty directory)的意思啊！那如果要將所有目錄下的東西都殺掉呢？！
		這個時候就必須使用『 rm -r test 』囉！不過，還是使用 rmdir 比較不危險！你也可以嘗試以 -p 
		的選項加入，來刪除上層的目錄喔！</p>
	</div>

	<hr /><a name="dir_path"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">關於執行檔路徑的變數： $PATH</span>
	<div class="block2">
		<p>經過第六章FHS的說明後，我們知道查閱檔案屬性的指令ls完整檔名為：/bin/ls(這是絕對路徑)，
		那你會不會覺得很奇怪：『<span class="text_import2">為什麼我可以在任何地方執行/bin/ls這個指令呢？</span> 』
		為什麼我在任何目錄下輸入 ls 就一定可以顯示出一些訊息而不會說找不到該 /bin/ls 指令呢？
		<span class="text_import2">這是因為環境變數 PATH 的幫助所致呀</span>！</p>

		<p>當我們在執行一個指令的時候，舉例來說『ls』好了，系統會依照PATH的設定去每個PATH定義的目錄下搜尋檔名為ls的可執行檔，
		如果在PATH定義的目錄中含有多個檔名為ls的可執行檔，那麼先搜尋到的同名指令先被執行！</p>

		<p>現在，請下達『echo $PATH』來看看到底有哪些目錄被定義出來了？
		echo有『顯示、印出』的意思，而 PATH 前面加的 $ 表示後面接的是變數，所以會顯示出目前的 PATH ！</p>

<table class="term"><tr><td class="term"><pre>
<span class="term_hd">範例：先用root的身份列出搜尋的路徑為何？</span>
[root@www ~]# <span class="term_command">echo $PATH</span>
/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin:/usr/local/bin:/sbin
:<span class="term_write">/bin</span>:/usr/sbin:/usr/bin:/root/bin  <span class="term_note">&lt;==這是同一行！</span>

<span class="term_hd">範例：用vbird的身份列出搜尋的路徑為何？</span>
[root@www ~]# <span class="term_command">su - vbird</span>
[vbird@www ~]# <span class="term_command">echo $PATH</span>
/usr/kerberos/bin:/usr/local/bin:<span class="term_write">/bin</span>:/usr/bin:/home/vbird/bin
<span class="term_say"># 仔細看，一般用戶vbird的PATH中，並不包含任何『sbin』的目錄存在喔！</span>
</pre></td></tr></table>

		<p>PATH(一定是大寫)這個變數的內容是由一堆目錄所組成的，每個目錄中間用冒號(:)來隔開，
		每個目錄是有『順序』之分的。仔細看一下上面的輸出，妳可以發現到無論是root還是vbird都有/bin
		這個目錄在PATH變數內，所以當然就能夠在任何地方執行ls來找到/bin/ls執行檔囉！</p>

		<p>我們用幾個範例來讓你瞭解一下，為什麼PATH是那麼重要的項目！</p>

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">
請問你能不能使用一般身份使用者下達ifconfig eth0這個指令呢？
</div>
答：<div class="block2">
如上面的範例所示，當你使用vbird這個帳號執行ifconfig時，會出現『-bash: ifconfig: command not found』的字樣，
因為ifconfig的是放置到/sbin底下，而由上表的結果中我們可以發現vbird的PATH並沒有設置/sbin，
所以預設無法執行。<br /><br />
但是你可以使用『/sbin/ifconfig eth0』來執行這個指令喔！因為一般用戶還是可以使用ifconfig來查詢系統IP的參數，
既然PATH沒有規範到/sbin，那麼<span class="text_import2">我們使用『絕對路徑』也可以執行到該指令的</span>！

</div>
</td></tr></table><br />

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">
假設你是root，如果你將ls由/bin/ls移動成為/root/ls(可用『mv /bin/ls /root』指令達成)，然後你自己本身也在/root目錄下，
請問(1)你能不能直接輸入ls來執行？(2)若不能，你該如何執行ls這個指令？(3)若要直接輸入ls即可執行，又該如何進行？
</div>
答：<div class="block2">
由於這個例題的重點是將某個執行檔移動到非正規目錄去，所以我們先要進行底下的動作才行：(務必使用root的身份)<br />
<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">mv /bin/ls /root</span>
<span class="term_say"># mv 為移動，可將檔案在不同的目錄間進行移動作業</span>

</pre></td></tr></table>
(1)接下來不論你在那個目錄底下輸入任何與ls相關的指令，都沒有辦法順利的執行ls了！
也就是說，你不能直接輸入ls來執行，<span class="text_import2">因為/root這個目錄並不在PATH指定的目錄中，
所以，即使你在/root目錄下，也不能夠搜尋到ls這個指令！</span><br /><br />
(2)因為這個ls確實存在於/root底下，並不是被刪除了！所以我們可以透過使用絕對路徑或者是相對路徑直接指定這個執行檔檔名，
底下的兩個方法都能夠執行ls這個指令：<br />

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">/root/ls</span>  <span class="term_note">&lt;==直接用絕對路徑指定該檔名</span>
[root@www ~]# <span class="term_command">./ls    </span>  <span class="term_note">&lt;==因為在 /root 目錄下，就用./ls來指定</span>

</pre></td></tr></table>

(3)如果想要讓root在任何目錄均可執行/root底下的ls，那麼就將/root加入PATH當中即可。
加入的方法很簡單，就像底下這樣：<br />

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">PATH="$PATH":/root</span>
</pre></td></tr></table>
上面這個作法就能夠將/root加入到執行檔搜尋路徑PATH中了！不相信的話請您自行使用『echo $PATH』去查看吧！
如果確定這個例題進行沒有問題了，請將ls搬回/bin底下，不然系統會掛點的！<br />

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">mv /root/ls /bin</span>

</pre></td></tr></table>
</div>
</td></tr></table><br />

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">
如果我有兩個ls指令在不同的目錄中，例如/usr/local/bin/ls與/bin/ls那麼當我下達 ls 的時候，哪個ls會被執行？
</div>
答：<div class="block2">
那還用說，就找出 PATH 裡面哪個目錄先被查詢，則那個目錄下的指令就會被先執行了！
</div>
</td></tr></table><br />

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">

為什麼PATH搜尋的目錄不加入本目錄(.)？加入本目錄的搜尋不是也不錯？
</div>
答：<div class="block2">
如果在PATH中加入本目錄(.)後，確實我們就能夠在指令所在目錄進行指令的執行了。
但是由於你的工作目錄並非固定(常常會使用cd來切換到不同的目錄)，
因此能夠執行的指令會有變動(因為每個目錄底下的可執行檔都不相同嘛！)，這對使用者來說並非好事。<br /><br />
另外，如果有個壞心使用者在/tmp底下做了一個指令，因為/tmp是大家都能夠寫入的環境，所以他當然可以這樣做。
假設該指令可能會竊取使用者的一些資料，如果你使用root的身份來執行這個指令，那不是很糟糕？
如果這個指令的名稱又是經常會被用到的ls時，那『中標』的機率就更高了！<br /><br />
所以，<span class="text_import2">為了安全起見，不建議將『.』加入PATH的搜尋目錄中。</span>
</div>
</td></tr></table><br />


		<p>而由上面的幾個例題我們也可以知道幾件事情：</p>

		<ul class="text_import2">
		<li>不同身份使用者預設的PATH不同，預設能夠隨意執行的指令也不同(如root與vbird)；</li>
		<li>PATH是可以修改的，所以一般使用者還是可以透過修改PATH來執行某些位於/sbin或/usr/sbin下的指令來查詢；</li>
		<li>使用絕對路徑或相對路徑直接指定某個指令的檔名來執行，會比搜尋PATH來的正確；</li>
		<li>指令應該要放置到正確的目錄下，執行才會比較方便；</li>
		<li>本目錄(.)最好不要放到PATH當中。</li>

		</ul>
		<p>對於PATH更詳細的『變數』說明，我們會在第三篇的<a 
		href="/linux_basic/0320bash.php">bash shell</a>中詳細說明的！</p>
	</div>
</div>

<hr /><a name="file_dir_manage"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">檔案與目錄管理：</span><br />
<div class="block1">
	<p>談了談目錄與路徑之後，再來討論一下關於檔案的一些基本管理吧！檔案與目錄的管理上，不外乎『顯示屬性』、
	『拷貝』、『刪除檔案』及『移動檔案或目錄』等等，由於檔案與目錄的管理在 Linux 當中是很重要的，
	尤其是每個人自己家目錄的資料也都需要注意管理！所以我們來談一談有關檔案與目錄的一些基礎管理部分吧！<br /><br /></p>

	<hr /><a name="ls"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">檔案與目錄的檢視： ls</span>
	<div class="block2">

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">ls [-aAdfFhilnrRSt] 目錄名稱</span>
[root@www ~]# <span class="term_command">ls [--color={never,auto,always}] 目錄名稱</span>
[root@www ~]# <span class="term_command">ls [--full-time] 目錄名稱</span>

<span class="term_say">選項與參數：
<span style="text-decoration:underline">-a  ：全部的檔案，連同隱藏檔( 開頭為 . 的檔案) 一起列出來(常用)</span>
-A  ：全部的檔案，連同隱藏檔，但不包括 . 與 .. 這兩個目錄
<span style="text-decoration:underline">-d  ：僅列出目錄本身，而不是列出目錄內的檔案資料(常用)</span>
-f  ：直接列出結果，而不進行排序 (ls 預設會以檔名排序！)
-F  ：根據檔案、目錄等資訊，給予附加資料結構，例如：
      *:代表可執行檔； /:代表目錄； =:代表 socket 檔案； |:代表 FIFO 檔案；
-h  ：將檔案容量以人類較易讀的方式(例如 GB, KB 等等)列出來；
-i  ：列出 inode 號碼，inode 的意義下一章將會介紹；
<span style="text-decoration:underline">-l  ：長資料串列出，包含檔案的屬性與權限等等資料；(常用)</span>
-n  ：列出 UID 與 GID 而非使用者與群組的名稱 (UID與GID會在帳號管理提到！)
-r  ：將排序結果反向輸出，例如：原本檔名由小到大，反向則為由大到小；
-R  ：連同子目錄內容一起列出來，等於該目錄下的所有檔案都會顯示出來；
-S  ：以檔案容量大小排序，而不是用檔名排序；
-t  ：依時間排序，而不是用檔名。
--color=never  ：不要依據檔案特性給予顏色顯示；
--color=always ：顯示顏色
--color=auto   ：讓系統自行依據設定來判斷是否給予顏色
--full-time    ：以完整時間模式 (包含年、月、日、時、分) 輸出
--time={atime,ctime} ：輸出 access 時間或改變權限屬性時間 (ctime) 
                       而非內容變更時間 (modification time)</span>
</pre></td></tr></table>

		<p>在Linux系統當中，這個 ls 指令可能是最常被執行的吧！因為我們隨時都要知道檔案或者是目錄的相關資訊啊～
		不過，我們Linux的檔案所記錄的資訊實在是太多了，ls 沒有需要全部都列出來呢～
		所以，當你只有下達 ls 時，預設顯示的只有：<span class="text_import2">非隱藏檔的檔名、
		以檔名進行排序及檔名代表的顏色顯示</span>如此而已。舉例來說，
		你下達『 ls /etc 』之後，只有經過排序的檔名以及以藍色顯示目錄及白色顯示一般檔案，如此而已。</p>

		<p>那如果我還想要加入其他的顯示資訊時，可以加入上頭提到的那些有用的選項呢～
		舉例來說，我們之前一直用到的 -l 這個長串顯示資料內容，以及將隱藏檔也一起列示出來的 -a 選項等等。
		底下則是一些常用的範例，實際試做看看：</p>

<table class="term"><tr><td class="term"><pre>
<span class="term_hd">範例一：將家目錄下的所有檔案列出來(含屬性與隱藏檔)</span>
[root@www ~]# <span class="term_command">ls -al ~</span>
total 156
drwxr-x---  4 root root  4096 Sep 24 00:07 <span style="color:#000088">.</span>
drwxr-xr-x 23 root root  4096 Sep 22 12:09 <span style="color:#000088">..</span>

-rw-------  1 root root  1474 Sep  4 18:27 anaconda-ks.cfg
-rw-------  1 root root   955 Sep 24 00:08 .bash_history
-rw-r--r--  1 root root    24 Jan  6  2007 .bash_logout
-rw-r--r--  1 root root   191 Jan  6  2007 .bash_profile
-rw-r--r--  1 root root   176 Jan  6  2007 .bashrc
drwx------  3 root root  4096 Sep  5 10:37 <span style="color:#000088">.gconf</span>
-rw-r--r--  1 root root 42304 Sep  4 18:26 install.log
-rw-r--r--  1 root root  5661 Sep  4 18:25 install.log.syslog
<span class="term_say"># 這個時候你會看到以 . 為開頭的幾個檔案，以及目錄檔 (.) (..) .gconf 等等，
# 不過，目錄檔檔名都是以深藍色顯示，有點不容易看清楚就是了。</span>

<span class="term_hd">範例二：承上題，不顯示顏色，但在檔名末顯示出該檔名代表的類型(type)</span>
[root@www ~]# <span class="term_command">ls -alF --color=never  ~</span>
total 156
drwxr-x---  4 root root  4096 Sep 24 00:07 ./
drwxr-xr-x 23 root root  4096 Sep 22 12:09 ../
-rw-------  1 root root  1474 Sep  4 18:27 anaconda-ks.cfg
-rw-------  1 root root   955 Sep 24 00:08 .bash_history
-rw-r--r--  1 root root    24 Jan  6  2007 .bash_logout
-rw-r--r--  1 root root   191 Jan  6  2007 .bash_profile
-rw-r--r--  1 root root   176 Jan  6  2007 .bashrc
drwx------  3 root root  4096 Sep  5 10:37 .gconf/
-rw-r--r--  1 root root 42304 Sep  4 18:26 install.log
-rw-r--r--  1 root root  5661 Sep  4 18:25 install.log.syslog
<span class="term_say"># 注意看到顯示結果的第一行，嘿嘿～知道為何我們會下達類似 ./command 
# 之類的指令了吧？因為 ./ 代表的是『目前目錄下』的意思啊！至於什麼是 FIFO/Socket ？
# 請參考前一章節的介紹啊！另外，那個.bashrc 時間僅寫2007，能否知道詳細時間？</span>

<span class="term_hd">範例三：完整的呈現檔案的修改時間 *(modification time)</span>

[root@www ~]# <span class="term_command">ls -al --full-time  ~</span>
total 156
drwxr-x---  4 root root  4096 2008-09-24 00:07:00.000000 +0800 .
drwxr-xr-x 23 root root  4096 2008-09-22 12:09:32.000000 +0800 ..
-rw-------  1 root root  1474 2008-09-04 18:27:10.000000 +0800 anaconda-ks.cfg
-rw-------  1 root root   955 2008-09-24 00:08:14.000000 +0800 .bash_history
-rw-r--r--  1 root root    24 2007-01-06 17:05:04.000000 +0800 .bash_logout
-rw-r--r--  1 root root   191 2007-01-06 17:05:04.000000 +0800 .bash_profile
-rw-r--r--  1 root root   176 2007-01-06 17:05:04.000000 +0800 .bashrc
drwx------  3 root root  4096 2008-09-05 10:37:49.000000 +0800 .gconf
-rw-r--r--  1 root root 42304 2008-09-04 18:26:57.000000 +0800 install.log
-rw-r--r--  1 root root  5661 2008-09-04 18:25:55.000000 +0800 install.log.syslog
<span class="term_say"># 請仔細看，上面的『時間』欄位變了喔！變成較為完整的格式。
# 一般來說， ls -al 僅列出目前短格式的時間，有時不會列出年份，
# 藉由 --full-time 可以查閱到比較正確的完整時間格式啊！</span>
</pre></td></tr></table>

		<p>其實 ls 的用法還有很多，包括查閱檔案所在 i-node 號碼的 ls -i 選項，以及用來進行檔案排序的 -S 
		選項，還有用來查閱不同時間的動作的 --time=atime 等選項(更多時間說明請參考本章後面<a 
		href="#touch">touch</a>的說明)。而這些選項的存在都是因為 Linux 
		檔案系統記錄了很多有用的資訊的緣故。那麼 Linux 的檔案系統中，這些與權限、屬性有關的資料放在哪裡呢？
		放在 i-node 裡面。關於這部分，我們會在下一章繼續為你作比較深入的介紹啊！</p>

		<p>無論如何， ls 最常被使用到的功能還是那個 -l 的選項，為此，很多 distribution 在預設的情況中，
		已經將 ll (L 的小寫) 設定成為 ls -l 的意思了！其實，那個功能是 <a 
		href="/linux_basic/0320bash.php">Bash shell</a> 的 <a href="/linux_basic/0320bash.php#alias">alias</a>

		功能呢～也就是說，我們直接輸入 ll 就等於是輸入 ls -l 是一樣的～關於這部分，我們會在後續 bash shell
		時再次的強調滴～</p>
	</div>

	<hr /><a name="cprmmv"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">複製、刪除與移動： cp, rm, mv</span>
	<div class="block2">
		<p>要複製檔案，請使用 cp (copy) 這個指令即可～不過， cp 這個指令的用途可多了～
		除了單純的複製之外，還可以建立連結檔 (就是捷徑囉)，比對兩檔案的新舊而予以更新，
		以及複製整個目錄等等的功能呢！至於移動目錄與檔案，則使用 mv (move)，
		這個指令也可以直接拿來作更名 (rename) 的動作喔！至於移除嗎？那就是 rm (remove)
		這個指令囉～底下我們就來瞧一瞧先～<br /><br /></p>

		<a name="cp"></a>

		<hr /><ul class="list1"><li class="text_import1">cp (複製檔案或目錄)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">cp [-adfilprsu] 來源檔(source) 目標檔(destination)</span>
[root@www ~]# <span class="term_command">cp [options] source1 source2 source3 .... directory</span>
<span class="term_say">選項與參數：
<span style="text-decoration:underline">-a  ：相當於 -pdr 的意思，至於 pdr 請參考下列說明；(常用)</span>
-d  ：若來源檔為連結檔的屬性(link file)，則複製連結檔屬性而非檔案本身；
-f  ：為強制(force)的意思，若目標檔案已經存在且無法開啟，則移除後再嘗試一次；
<span style="text-decoration:underline">-i  ：若目標檔(destination)已經存在時，在覆蓋時會先詢問動作的進行(常用)</span>

-l  ：進行硬式連結(hard link)的連結檔建立，而非複製檔案本身；
<span style="text-decoration:underline">-p  ：連同檔案的屬性一起複製過去，而非使用預設屬性(備份常用)；</span>
<span style="text-decoration:underline">-r  ：遞迴持續複製，用於目錄的複製行為；(常用)</span>
-s  ：複製成為符號連結檔 (symbolic link)，亦即『捷徑』檔案；
-u  ：若 destination 比 source 舊才更新 destination ！
最後需要注意的，如果來源檔有兩個以上，則最後一個目的檔一定要是『目錄』才行！</span>
</pre></td></tr></table>

		<p>複製(cp)這個指令是非常重要的，不同身份者執行這個指令會有不同的結果產生，尤其是那個-a, -p的選項，
		對於不同身份來說，差異則非常的大！底下的練習中，有的身份為root有的身份為一般帳號(在我這裡用vbird這個帳號)，
		練習時請特別注意身份的差別喔！好！開始來做複製的練習與觀察：</p>

<table class="term"><tr><td class="term"><pre>
<span class="term_hd">範例一：用root身份，將家目錄下的 .bashrc 複製到 /tmp 下，並更名為 bashrc</span>
[root@www ~]# <span class="term_command">cp ~/.bashrc /tmp/bashrc</span>

[root@www ~]# <span class="term_command">cp -i ~/.bashrc /tmp/bashrc</span>
cp: overwrite `/tmp/bashrc'? <span class="term_command">n</span>  <span class="term_note">&lt;==n不覆蓋，y為覆蓋</span>
<span class="term_say"># 重複作兩次動作，由於 /tmp 底下已經存在 bashrc 了，加上 -i 選項後，
# 則在覆蓋前會詢問使用者是否確定！可以按下 n 或者 y 來二次確認呢！</span>

<span class="term_hd">範例二：變換目錄到/tmp，並將/var/log/wtmp複製到/tmp且觀察屬性：</span>
[root@www ~]# <span class="term_command">cd /tmp</span>
[root@www tmp]# <span class="term_command">cp /var/log/wtmp .</span> <span class="term_note">&lt;==想要複製到目前的目錄，最後的 . 不要忘</span>

[root@www tmp]# <span class="term_command">ls -l /var/log/wtmp wtmp</span>
<span class="term_write">-rw-rw-r--</span> 1 root <span class="term_write">utmp</span> 96384 Sep 24 <span class="term_write">11:54</span> /var/log/wtmp
<span class="term_write">-rw-r--r--</span> 1 root <span class="term_write">root</span> 96384 Sep 24 <span class="term_write">14:06</span> wtmp

<span class="term_say"># 注意上面的特殊字體，在不加任何選項的情況下，檔案的某些屬性/權限會改變；
# 這是個很重要的特性！要注意喔！還有，連檔案建立的時間也不一樣了！
# 那如果你想要將檔案的所有特性都一起複製過來該怎辦？可以加上 -a 喔！如下所示：</span>

[root@www tmp]# <span class="term_command">cp -a /var/log/wtmp wtmp_2</span>
[root@www tmp]# <span class="term_command">ls -l /var/log/wtmp wtmp_2</span>
-rw-rw-r-- 1 root utmp 96384 Sep 24 11:54 /var/log/wtmp
-rw-rw-r-- 1 root utmp 96384 Sep 24 11:54 wtmp_2
<span class="term_say"># 瞭了吧！整個資料特性完全一模一樣ㄟ！真是不賴～這就是 -a 的特性！</span>
</pre></td></tr></table>

		<p>這個 cp 的功能很多，由於我們常常會進行一些資料的複製，所以也會常常用到這個指令的。
		一般來說，我們如果去複製別人的資料 (當然，該檔案你必須要有 read 的權限才行啊！ ^_^) 時，
		總是希望複製到的資料最後是我們自己的，所以，<span class="text_import2">在預設的條件中， cp 
		的來源檔與目的檔的權限是不同的，目的檔的擁有者通常會是指令操作者本身</span>。舉例來說，
		上面的範例二中，由於我是 root 的身份，因此複製過來的檔案擁有者與群組就改變成為 root 所有了！
		這樣說，可以明白嗎？^_^</p>

		<p>由於具有這個特性，因此當我們在進行備份的時候，某些需要特別注意的特殊權限檔案，
		例如密碼檔 (/etc/shadow) 以及一些設定檔，就不能直接以 cp 來複製，而必須要加上 -a 或者是 -p 
		等等可以完整複製檔案權限的選項才行！另外，如果你想要複製檔案給其他的使用者，
		也必須要注意到檔案的權限(包含讀、寫、執行以及檔案擁有者等等)，
		否則，其他人還是無法針對你給予的檔案進行修訂的動作喔！注意注意！</p>

<table class="term"><tr><td class="term"><pre>
<span class="term_hd">範例三：複製 /etc/ 這個目錄下的所有內容到 /tmp 底下</span>
[root@www tmp]# <span class="term_command">cp /etc/ /tmp</span>
cp: omitting directory `/etc'   <span class="term_note">&lt;== 如果是目錄則不能直接複製，要加上 -r 的選項</span>
[root@www tmp]# <span class="term_command">cp -r /etc/ /tmp</span>

<span class="term_say"># 還是要再次的強調喔！ -r 是可以複製目錄，但是，檔案與目錄的權限可能會被改變
# 所以，也可以利用『 cp -a /etc /tmp 』來下達指令喔！尤其是在備份的情況下！</span>

<span class="term_hd">範例四：將範例一複製的 bashrc 建立一個連結檔 (symbolic link)</span>
[root@www tmp]# <span class="term_command">ls -l bashrc</span>
-rw-r--r-- 1 root root 176 Sep 24 14:02 bashrc  <span class="term_note">&lt;==先觀察一下檔案情況</span>
[root@www tmp]# <span class="term_command">cp -s bashrc bashrc_slink</span>
[root@www tmp]# <span class="term_command">cp -l bashrc bashrc_hlink</span>

[root@www tmp]# <span class="term_command">ls -l bashrc*</span>
-rw-r--r-- <span class="term_write">2</span> root root 176 Sep 24 14:02 bashrc  <span class="term_note">&lt;==與原始檔案不太一樣了！</span>
-rw-r--r-- <span class="term_write">2</span> root root 176 Sep 24 14:02 bashrc_hlink
lrwxrwxrwx 1 root root   6 Sep 24 14:20 bashrc_slink -&gt; bashrc
</pre></td></tr></table>

		<p>範例四可有趣了！使用 -l 及 -s 都會建立所謂的連結檔(link file)，但是這兩種連結檔卻有不一樣的情況。這是怎麼一回事啊？
		那個 -l 就是所謂的實體連結(hard link)，至於 -s 則是符號連結(symbolic link)，
		簡單來說，bashrc_slink 是一個『捷徑』，這個捷徑會連結到bashrc去！所以你會看到檔名右側會有個指向(-&gt;)的符號！</p>

		<p>至於bashrc_hlink檔案與bashrc的屬性與權限完全一模一樣，與尚未進行連結前的差異則是第二欄的link數由1變成2了！
		鳥哥這裡先不介紹實體連結，因為實體連結涉及 i-node 的相關知識，我們下一章談到檔案系統(filesystem)時再來討論這個問題。
		</p>

<table class="term"><tr><td class="term"><pre>
<span class="term_hd">範例五：若 ~/.bashrc 比 /tmp/bashrc 新才複製過來</span>
[root@www tmp]# <span class="term_command">cp -u ~/.bashrc /tmp/bashrc</span>
<span class="term_say"># 這個 -u 的特性，是在目標檔案與來源檔案有差異時，才會複製的。
# 所以，比較常被用於『備份』的工作當中喔！ ^_^</span>

<span class="term_hd">範例六：將範例四造成的 bashrc_slink 複製成為 bashrc_slink_1 與bashrc_slink_2</span>
[root@www tmp]# <span class="term_command">cp bashrc_slink bashrc_slink_1</span>
[root@www tmp]# <span class="term_command">cp -d bashrc_slink bashrc_slink_2</span>
[root@www tmp]# <span class="term_command">ls -l bashrc bashrc_slink*</span>
-rw-r--r-- 2 root root 176 Sep 24 14:02 bashrc
lrwxrwxrwx 1 root root   6 Sep 24 14:20 bashrc_slink -&gt; bashrc
-rw-r--r-- 1 root root 176 Sep 24 14:32 bashrc_slink_1       <span class="term_note">&lt;==與原始檔案相同</span>

lrwxrwxrwx 1 root root   6 Sep 24 14:33 bashrc_slink_2 -&gt; bashrc <span class="term_note">&lt;==是連結檔！</span>
<span class="term_say"># 這個例子也是很有趣喔！原本複製的是連結檔，但是卻將連結檔的實際檔案複製過來了
# 也就是說，如果沒有加上任何選項時，cp複製的是原始檔案，而非連結檔的屬性！
# 若要複製連結檔的屬性，就得要使用 -d 的選項了！如 bashrc_slink_2 所示。</span>

<span class="term_hd">範例七：將家目錄的 .bashrc 及 .bash_history 複製到 /tmp 底下</span>
[root@www tmp]# <span class="term_command">cp ~/.bashrc ~/.bash_history /tmp</span>
<span class="term_say"># 可以將多個資料一次複製到同一個目錄去！最後面一定是目錄！</span>
</pre></td></tr></table>

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">
你能否使用vbird的身份，完整的複製/var/log/wtmp檔案到/tmp底下，並更名為vbird_wtmp呢？
</div>
答：<div class="block2">
實際做看看的結果如下：<br />

<table class="term"><tr><td class="term"><pre>
[vbird@www ~]$ <span class="term_command">cp -a /var/log/wtmp /tmp/vbird_wtmp</span>
[vbird@www ~]$ <span class="term_command">ls -l /var/log/wtmp /tmp/vbird_wtmp</span>

-rw-rw-r-- 1 <span class="term_write">vbird vbird</span> 96384  9月 24 11:54 /tmp/vbird_wtmp
-rw-rw-r-- 1 <span class="term_write">root  utmp </span> 96384  9月 24 11:54 /var/log/wtmp
</pre></td></tr></table>
由於vbird的身份並不能隨意修改檔案的擁有者與群組，因此雖然能夠複製wtmp的相關權限與時間等屬性，
但是與擁有者、群組相關的，原本vbird身份無法進行的動作，即使加上 -a 選項，也是無法達成完整複製權限的！
</div>
</td></tr></table><br />

		<p>總之，由於 cp 有種種的檔案屬性與權限的特性，所以，在複製時，你必須要清楚的瞭解到：</p>
		<ul class="text_import2">

		<li>是否需要完整的保留來源檔案的資訊？</li>
		<li>來源檔案是否為連結檔 (symbolic link file)？</li>
		<li>來源檔是否為特殊的檔案，例如 FIFO, socket 等？</li>
		<li>來源檔是否為目錄？</li></ul><br />

		<a name="rm"></a>
		<hr /><ul class="list1"><li class="text_import1">rm  (移除檔案或目錄)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">rm [-fir] 檔案或目錄</span>
<span class="term_say">選項與參數：
-f  ：就是 force 的意思，忽略不存在的檔案，不會出現警告訊息；
-i  ：互動模式，在刪除前會詢問使用者是否動作
-r  ：遞迴刪除啊！最常用在目錄的刪除了！<span style="text-decoration: underline">這是非常危險的選項！！！</span></span>

<span class="term_hd">範例一：將剛剛在 cp 的範例中建立的 bashrc 刪除掉！</span>
[root@www ~]# <span class="term_command">cd /tmp</span>
[root@www tmp]# <span class="term_command">rm -i bashrc</span>

rm: remove regular file `bashrc'? <span class="term_command">y</span>
<span class="term_say"># 如果加上 -i 的選項就會主動詢問喔，避免你刪除到錯誤的檔名！</span>

<span class="term_hd">範例二：透過萬用字元*的幫忙，將/tmp底下開頭為bashrc的檔名通通刪除：</span>
[root@www tmp]# <span class="term_command">rm -i bashrc*</span>
<span class="term_say"># 注意那個星號，代表的是 0 到無窮多個任意字元喔！很好用的東西！</span>

<span class="term_hd">範例三：將 cp 範例中所建立的 /tmp/etc/ 這個目錄刪除掉！</span>
[root@www tmp]# <span class="term_command">rmdir /tmp/etc</span>

rmdir: etc: Directory not empty  <span class="term_note">&lt;== 刪不掉啊！因為這不是空的目錄！</span>
[root@www tmp]# <span class="term_command">rm -r /tmp/etc</span>
rm: descend into directory `/tmp/etc'? <span class="term_command">y</span>
<span class="term_say">....(中間省略)....
# 因為身份是 root ，預設已經加入了 -i 的選項，所以你要一直按 y 才會刪除！
# 如果不想要繼續按 y ，可以按下『 [ctrl]-c 』來結束 rm 的工作。
# 這是一種保護的動作，如果確定要刪除掉此目錄而不要詢問，可以這樣做：</span>
[root@www tmp]# <span class="term_command">\rm -r /tmp/etc</span>
<span class="term_say"># 在指令前加上反斜線，可以忽略掉 alias 的指定選項喔！至於 alias 我們在bash再談！</span>

<span class="term_hd">範例四：刪除一個帶有 - 開頭的檔案</span>
[root@www tmp]# <span class="term_command">touch ./-aaa-</span>  <span class="term_note">&lt;==<a href="#touch">touch</a>這個指令可以建立空檔案！</span>
[root@www tmp]# <span class="term_command">ls -l </span>
-rw-r--r-- 1 root  root      0 Sep 24 15:03 -aaa-  <span class="term_note">&lt;==檔案大小為0，所以是空檔案</span>
[root@www tmp]# <span class="term_command">rm -aaa-</span>

Try `rm --help' for more information.  <span class="term_say">&lt;== 因為 "-" 是選項嘛！所以系統誤判了！</span>
[root@www tmp]# <span class="term_command">rm ./-aaa-</span>
</pre></td></tr></table>

		<p>這是移除的指令(remove)，要注意的是，通常在Linux系統下，為了怕檔案被誤殺，所以很多 
		distributions 都已經預設加入 -i 這個選項了！而如果要連目錄下的東西都一起殺掉的話，
		例如子目錄裡面還有子目錄時，那就要使用 -r 這個選項了！<span class="text_import2">不過，使用『 
		rm -r 』這個指令之前，請千萬注意了，因為該目錄或檔案『肯定』會被 root 
		殺掉</span>！因為系統不會再次詢問你是否要砍掉呦！所以那是個超級嚴重的指令下達呦！
		得特別注意！不過，如果你確定該目錄不要了，那麼使用 rm -r 來循環殺掉是不錯的方式！</p>

		另外，範例四也是很有趣的例子，我們在之前就談過，檔名最好不要使用 "-" 號開頭，
		因為 "-" 後面接的是選項，因此，單純的使用『 rm -aaa- 』系統的指令就會誤判啦！
		那如果使用後面會談到的正規表示法時，還是會出問題的！所以，只能用避過首位字元是 "-" 的方法啦！
		就是加上本目錄『 ./ 』即可！如果 man rm 的話，其實還有一種方法，那就是『 rm -- -aaa- 
		』也可以啊！<br /><br />

		<a name="mv"></a>
		<hr /><ul class="list1"><li class="text_import1">mv  (移動檔案與目錄，或更名)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">mv [-fiu] source destination</span>
[root@www ~]# <span class="term_command">mv [options] source1 source2 source3 .... directory</span>
<span class="term_say">選項與參數：
-f  ：force 強制的意思，如果目標檔案已經存在，不會詢問而直接覆蓋；
-i  ：若目標檔案 (destination) 已經存在時，就會詢問是否覆蓋！
-u  ：若目標檔案已經存在，且 source 比較新，才會更新 (update)</span>

<span class="term_hd">範例一：複製一檔案，建立一目錄，將檔案移動到目錄中</span>
[root@www ~]# <span class="term_command">cd /tmp</span>
[root@www tmp]# <span class="term_command">cp ~/.bashrc bashrc</span>
[root@www tmp]# <span class="term_command">mkdir mvtest</span>
[root@www tmp]# <span class="term_command">mv bashrc mvtest</span>
<span class="term_say"># 將某個檔案移動到某個目錄去，就是這樣做！</span>

<span class="term_hd">範例二：將剛剛的目錄名稱更名為 mvtest2</span>
[root@www tmp]# <span class="term_command">mv mvtest mvtest2</span> <span class="term_note">&lt;== 這樣就更名了！簡單～</span>
<span class="term_say"># 其實在 Linux 底下還有個有趣的指令，名稱為 <span class="term_note_b">rename</span> ，
# 該指令專職進行多個檔名的同時更名，並非針對單一檔名變更，與mv不同。請man rename。</span>

<span class="term_hd">範例三：再建立兩個檔案，再全部移動到 /tmp/mvtest2 當中</span>
[root@www tmp]# <span class="term_command">cp ~/.bashrc bashrc1</span>

[root@www tmp]# <span class="term_command">cp ~/.bashrc bashrc2</span>
[root@www tmp]# <span class="term_command">mv bashrc1 bashrc2 mvtest2</span>
<span class="term_say"># 注意到這邊，如果有多個來源檔案或目錄，則最後一個目標檔一定是『目錄！』
# 意思是說，將所有的資料移動到該目錄的意思！</span>
</pre></td></tr></table>

		<p>這是搬移 (move) 的意思！當你要移動檔案或目錄的時後，呵呵！這個指令就很重要啦！
		同樣的，你也可以使用 -u ( update )來測試新舊檔案，看看是否需要搬移囉！
		另外一個用途就是『<span class="text_import2">變更檔名</span>！』，我們可以很輕易的使用 
		mv 來變更一個檔案的檔名呢！不過，在 Linux 才有的指令當中，有個 rename ，
		可以用來更改大量檔案的檔名，你可以利用 man rename 來查閱一下，也是挺有趣的指令喔！</p>
	</div>

	<hr /><a name="dir_name"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">取得路徑的檔案名稱與目錄名稱</span>
	<div class="block2">
		<p>我們前面介紹的完整檔名 (包含目錄名稱與檔案名稱) 當中提到，完整檔名最長可以到達 4096 個字元。
		那麼你怎麼知道那個是檔名？那個是目錄名？嘿嘿！就是利用斜線 (/) 來分辨啊！
		其實，取得檔名或者是目錄名稱，一般的用途應該是在寫程式的時候，用來判斷之用的啦～
		所以，這部分的指令可以用在第三篇內的 shell scripts 裡頭喔！
		底下我們簡單的以幾個範例來談一談 basename 與 dirname 的用途！</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">basename /etc/sysconfig/network</span>
network         <span class="term_note">&lt;== 很簡單！就取得最後的檔名～</span>

[root@www ~]# <span class="term_command">dirname /etc/sysconfig/network</span>
/etc/sysconfig  <span class="term_note">&lt;== 取得的變成目錄名了！</span>
</pre></td></tr></table>
	</div>
</div>


<hr /><a name="file_content"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">檔案內容查閱：</span><br />
<div class="block1">
	<p>如果我們要查閱一個檔案的內容時，該如何是好呢？這裡有相當多有趣的指令可以來分享一下：
	最常使用的顯示檔案內容的指令可以說是 cat 與 more 及 less 了！此外，如果我們要查看一個很大型的檔案 
	(好幾百MB時)，但是我們只需要後端的幾行字而已，那麼該如何是好？呵呵！用 tail 呀，此外， 
	tac 這個指令也可以達到！好了，說說各個指令的用途吧！</p>

	<ul class="text_import2" style="font-family:'細明體'">
	<li>cat&nbsp;  由第一行開始顯示檔案內容</li>
	<li>tac&nbsp;  從最後一行開始顯示，可以看出 tac 是 cat 的倒著寫！</li>
	<li>nl &nbsp;&nbsp;顯示的時候，順道輸出行號！</li>
	<li>more 一頁一頁的顯示檔案內容</li>

	<li>less 與 more 類似，但是比 more 更好的是，他可以往前翻頁！</li>
	<li>head 只看頭幾行</li>
	<li>tail 只看尾巴幾行</li>
	<li>od&nbsp;&nbsp;   以二進位的方式讀取檔案內容！</li></ul>

	<hr /><a name="file_content_1"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">直接檢視檔案內容</span><br />

	<div class="block2">
		<p>直接查閱一個檔案的內容可以使用 cat/tac/nl 這幾個指令啊！<br /><br /></p>

		<a name="cat"></a>
		<hr /><ul class="list1"><li class="text_import1">cat (con<span style="text-decoration:underline">cat</span>enate)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">cat [-AbEnTv]</span>

<span class="term_say">選項與參數：
-A  ：相當於 -vET 的整合選項，可列出一些特殊字符而不是空白而已；
-b  ：列出行號，僅針對非空白行做行號顯示，空白行不標行號！
-E  ：將結尾的斷行字元 $ 顯示出來；
<span style="text-decoration: underline">-n  ：列印出行號，連同空白行也會有行號，與 -b 的選項不同；</span>
-T  ：將 [tab] 按鍵以 ^I 顯示出來；
-v  ：列出一些看不出來的特殊字符</span>

<span class="term_hd">範例一：檢閱 /etc/issue 這個檔案的內容</span>
[root@www ~]# <span class="term_command">cat /etc/issue</span>
CentOS release 5.3 (Final)
Kernel \r on an \m

<span class="term_hd">範例二：承上題，如果還要加印行號呢？</span>
[root@www ~]# <span class="term_command">cat -n /etc/issue</span>

     1  CentOS release 5.3 (Final)
     2  Kernel \r on an \m
     3
<span class="term_say"># 看到了吧！可以印出行號呢！這對於大檔案要找某個特定的行時，有點用處！
# 如果不想要編排空白行的行號，可以使用『cat -b /etc/issue』，自己測試看看：</span>

<span class="term_hd">範例三：將 /etc/xinetd.conf 的內容完整的顯示出來(包含特殊字元)</span>
[root@www ~]# <span class="term_command">cat -A /etc/xinetd.conf</span>
#<span class="term_write">$</span>
<span class="term_say">....(中間省略)....</span>
<span class="term_write">$</span>

defaults<span class="term_write">$</span>
{<span class="term_write">$</span>
# The next two items are intended to be a quick access place to<span class="term_write">$</span>
<span class="term_say">....(中間省略)....</span>
<span class="term_write">^I</span>log_type<span class="term_write">^I</span>= SYSLOG daemon info <span class="term_write">$</span>

<span class="term_write">^I</span>log_on_failure<span class="term_write">^I</span>= HOST<span class="term_write">$</span>
<span class="term_write">^I</span>log_on_success<span class="term_write">^I</span>= PID HOST DURATION EXIT<span class="term_write">$</span>
<span class="term_say">....(中間省略)....</span>
includedir /etc/xinetd.d<span class="term_write">$</span>

 <span class="term_write">$</span>
<span class="term_say"># 上面的結果限於篇幅，鳥哥刪除掉很多資料了。另外，輸出的結果並不會有特殊字體，
# 鳥哥上面的特殊字體是要讓您發現差異點在哪裡就是了。基本上，在一般的環境中，
# 使用 [tab] 與空白鍵的效果差不多，都是一堆空白啊！我們無法知道兩者的差別。
# 此時使用 cat -A 就能夠發現那些空白的地方是啥鬼東西了！[tab]會以 ^I 表示，
# 斷行字元則是以 $ 表示，所以你可以發現每一行後面都是 $ 啊！不過斷行字元
# 在Windows/Linux則不太相同，Windows的斷行字元是 ^M$ 囉。
# 這部分我們會在<a href="/linux_basic/0310vi.php#tips_dos">第十章 vim 軟體</a>的介紹時，再次的說明到喔！</span>
</pre></td></tr></table>

		<p>嘿嘿！Linux 裡面有『貓』指令？喔！不是的， cat 是 Concatenate （連續）的簡寫，
		主要的功能是將一個檔案的內容連續的印出在螢幕上面！例如上面的例子中，我們將 /etc/issue 
		印出來！如果加上 -n 或 -b 的話，則每一行前面還會加上行號呦！</p>

		<p>鳥哥個人是比較少用 cat 啦！畢竟當你的檔案內容的行數超過 40 行以上，嘿嘿！根本來不及在螢幕上看到結果！
		所以，配合等一下要介紹的 more 
		或者是 less 來執行比較好！此外，如果是一般的 DOS 檔案時，就需要特別留意一些奇奇怪怪的符號了，
		例如斷行與 [tab] 等，要顯示出來，就得加入 -A 之類的選項了！<br /><br /></p>

		<a name="tac"></a>
		<hr /><ul class="list1"><li class="text_import1">tac (反向列示)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">tac /etc/issue</span>

Kernel \r on an \m
CentOS release 5.3 (Final)
<span class="term_say"># 嘿嘿！與剛剛上面的範例一比較，是由最後一行先顯示喔！</span>
</pre></td></tr></table>

		<p>tac 這個好玩了！怎麼說呢？詳細的看一下， cat 與 tac ，有沒有發現呀！對啦！ 
		tac 剛好是將 cat 反寫過來，所以他的功能就跟 cat 相反啦， cat 
		是由『第一行到最後一行連續顯示在螢幕上』，而 tac 則是『
		<span class="text_import2">由最後一行到第一行反向在螢幕上顯示出來</span> 』，很好玩吧！<br /><br /></p>

		<a name="nl"></a>
		<hr /><ul class="list1"><li class="text_import1">nl (添加行號列印)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">nl [-bnw] 檔案</span>
<span class="term_say">選項與參數：
-b  ：指定行號指定的方式，主要有兩種：
      -b a ：表示不論是否為空行，也同樣列出行號(類似 cat -n)；
      -b t ：如果有空行，空的那一行不要列出行號(預設值)；
-n  ：列出行號表示的方法，主要有三種：
      -n ln ：行號在螢幕的最左方顯示；
      -n rn ：行號在自己欄位的最右方顯示，且不加 0 ；
      -n rz ：行號在自己欄位的最右方顯示，且加 0 ；
-w  ：行號欄位的佔用的位元數。</span>

<span class="term_hd">範例一：用 nl 列出 /etc/issue 的內容</span>
[root@www ~]# <span class="term_command">nl /etc/issue</span>

     1  CentOS release 5.3 (Final)
     2  Kernel \r on an \m

<span class="term_say"># 注意看，這個檔案其實有三行，第三行為空白(沒有任何字元)，
# 因為他是空白行，所以 nl 不會加上行號喔！如果確定要加上行號，可以這樣做：</span>

[root@www ~]# <span class="term_command">nl -b a /etc/issue</span>
     1  CentOS release 5.3 (Final)
     2  Kernel \r on an \m
     3
<span class="term_say"># 呵呵！行號加上來囉～那麼如果要讓行號前面自動補上 0 呢？可這樣</span>

[root@www ~]# <span class="term_command">nl -b a -n rz /etc/issue</span>
000001  CentOS release 5.3 (Final)
000002  Kernel \r on an \m
000003

<span class="term_say"># 嘿嘿！自動在自己欄位的地方補上 0 了～預設欄位是六位數，如果想要改成 3 位數？</span>

[root@www ~]# <span class="term_command">nl -b a -n rz -w 3 /etc/issue</span>
001     CentOS release 5.3 (Final)
002     Kernel \r on an \m
003
<span class="term_say"># 變成僅有 3 位數囉～</span>
</pre></td></tr></table>

		<p>nl 可以將輸出的檔案內容自動的加上行號！其預設的結果與 cat -n 有點不太一樣，
		nl 可以將行號做比較多的顯示設計，包括位數與是否自動補齊 0 等等的功能呢。</p>
	</div>

	<hr /><a name="file_content_2"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">可翻頁檢視</span><br />
	<div class="block2">
		<p>前面提到的 nl 與 cat, tac 等等，都是一次性的將資料一口氣顯示到螢幕上面，那有沒有可以進行一頁一頁翻動的指令啊？
		讓我們可以一頁一頁的觀察，才不會前面的資料看不到啊～呵呵！有的！那就是 more 與 less 囉～<br /><br /></p>

		<a name="more"></a>
		<hr /><ul class="list1"><li class="text_import1">more (一頁一頁翻動)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">more /etc/man.config</span>

#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
<span class="term_say">....(中間省略)....</span>
<span class="term_white">--More--(28%)</span>  <span class="term_note">&lt;== 重點在這一行喔！你的游標也會在這裡等待你的指令</span>
</pre></td></tr></table>

		<p>仔細的給他看到上面的範例，如果 more 後面接的檔案內容行數大於螢幕輸出的行數時，
		就會出現類似上面的圖示。重點在最後一行，最後一行會顯示出目前顯示的百分比，
		而且還可以在最後一行輸入一些有用的指令喔！在 more 這個程式的運作過程中，你有幾個按鍵可以按的：</p>
		<ul class="text_import2" style="font-family: '細明體'">
		<li>空白鍵 (space)：代表向下翻一頁；</li>

		<li>Enter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：代表向下翻『一行』；</li>
		<li>/字串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：代表在這個顯示的內容當中，向下搜尋『字串』這個關鍵字；</li>
		<li>:f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ：立刻顯示出檔名以及目前顯示的行數；</li>
		<li>q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：代表立刻離開 more ，不再顯示該檔案內容。</li>

		<li>b 或 [ctrl]-b ：代表往回翻頁，不過這動作只對檔案有用，對管線無用。</li>
		</ul>
		<p>要離開 more 這個指令的顯示工作，可以按下 q 就能夠離開了。而要向下翻頁，就使用空白鍵即可。
		比較有用的是搜尋字串的功能，舉例來說，我們使用『 more /etc/man.config 』來觀察該檔案，
		若想要在該檔案內搜尋 MANPATH 這個字串時，可以這樣做：</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">more /etc/man.config</span>
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
<span class="term_say">....(中間省略)....</span>
<span class="term_write">/MANPATH</span>   <span class="term_note">&lt;== 輸入了 / 之後，游標就會自動跑到最底下一行等待輸入！</span>

</pre></td></tr></table>

		<p>如同上面的說明，輸入了 / 之後，游標就會跑到最底下一行，並且等待你的輸入，
		你輸入了字串並按下[enter]之後，嘿嘿！ more 就會開始向下搜尋該字串囉～而重複搜尋同一個字串，
		可以直接按下 n 即可啊！最後，不想要看了，就按下 q 即可離開 more 啦！<br /><br /></p>

		<a name="less"></a>
		<hr /><ul class="list1"><li class="text_import1">less (一頁一頁翻動)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">less /etc/man.config</span>
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d

<span class="term_say">....(中間省略)....</span>
:<span class="term_white"> </span>  <span class="term_note">&lt;== 這裡可以等待你輸入指令！</span>
</pre></td></tr></table>

		<p>less 的用法比起 more 又更加的有彈性，怎麼說呢？在 more 的時候，我們並沒有辦法向前面翻，
		只能往後面看，但若使用了 less 時，呵呵！就可以使用 [pageup] [pagedown] 
		等按鍵的功能來往前往後翻看文件，你瞧，是不是更容易使用來觀看一個檔案的內容了呢！</p>

		<p>除此之外，在 less 裡頭可以擁有更多的『搜尋』功能喔！不止可以向下搜尋，也可以向上搜尋～
		實在是很不錯用～基本上，可以輸入的指令有：</p>

		<ul class="text_import2" style="font-family: '細明體'">
		<li>空白鍵&nbsp;&nbsp;&nbsp;&nbsp;：向下翻動一頁；</li>
		<li>[pagedown]：向下翻動一頁；</li>
		<li>[pageup]&nbsp;&nbsp;：向上翻動一頁；</li>
		<li>/字串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：向下搜尋『字串』的功能；</li>

		<li>?字串&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;：向上搜尋『字串』的功能；</li>
		<li>n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：重複前一個搜尋 (與 / 或 ? 有關！)</li>
		<li>N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：反向的重複前一個搜尋 (與 / 或 ? 有關！)</li>
		<li>q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：離開 less 這個程式；</li></ul>

		<p>查閱檔案內容還可以進行搜尋的動作～瞧～ less 是否很不錯用啊！
		其實 less 還有很多的功能喔！詳細的使用方式請使用 man less 查詢一下啊！ ^_^</p>

		<p>你是否會覺得 less 使用的畫面與環境與 <a href="/linux_basic/0160startlinux.php#manual_man">man page</a>
		非常的類似呢？沒錯啦！因為man這個指令就是呼叫 less 來顯示說明文件的內容的！
		現在你是否覺得 less 很重要呢？ ^_^</p>
	</div>

	<hr /><a name="file_content_3"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">資料擷取</span><br />

	<div class="block2">
		<p>我們可以將輸出的資料作一個最簡單的擷取，那就是取出前面 (head) 與取出後面 (tail) 文字的功能。
		不過，要注意的是， head 與 tail 都是以『行』為單位來進行資料擷取的喔！<br /><br /></p>

		<a name="head"></a>
		<hr /><ul class="list1"><li class="text_import1">head (取出前面幾行)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">head [-n number] 檔案 </span>
<span class="term_say">選項與參數：
-n  ：後面接數字，代表顯示幾行的意思</span>

[root@www ~]# <span class="term_command">head /etc/man.config</span>
<span class="term_say"># 預設的情況中，顯示前面十行！若要顯示前 20 行，就得要這樣：</span>
[root@www ~]# <span class="term_command">head -n 20 /etc/man.config</span>

<span class="term_hd">範例：如果後面100行的資料都不列印，只列印/etc/man.config的前面幾行，該如何是好？</span>
[root@www ~]# <span class="term_command">head -n -100 /etc/man.config</span>
</pre></td></tr></table>

		<p>head 的英文意思就是『頭』啦，那麼這個東西的用法自然就是顯示出一個檔案的前幾行囉！
		沒錯！就是這樣！若沒有加上 -n 這個選項時，預設只顯示十行，若只要一行呢？那就加入『 
		head -n 1 filename 』即可！</p>

		<p>另外那個 -n 選項後面的參數較有趣，如果接的是負數，例如上面範例的-n -100時，代表列前的所有行數，
		但不包括後面100行。舉例來說，/etc/man.config共有141行，則上述的指令『head -n -100 /etc/man.config』
		就會列出前面41行，後面100行不會列印出來了。這樣說，比較容易懂了吧？ ^_^<br /><br /></p>

		<a name="tail"></a>
		<hr /><ul class="list1"><li class="text_import1">tail (取出後面幾行)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">tail [-n number] 檔案 </span>

<span class="term_say">選項與參數：
-n  ：後面接數字，代表顯示幾行的意思
-f  ：表示持續偵測後面所接的檔名，要等到按下[ctrl]-c才會結束tail的偵測</span>

[root@www ~]# <span class="term_command">tail /etc/man.config</span>
<span class="term_say"># 預設的情況中，顯示最後的十行！若要顯示最後的 20 行，就得要這樣：</span>
[root@www ~]# <span class="term_command">tail -n 20 /etc/man.config</span>

<span class="term_hd">範例一：如果不知道/etc/man.config有幾行，卻只想列出100行以後的資料時？</span>
[root@www ~]# <span class="term_command">tail -n +100 /etc/man.config</span>

<span class="term_hd">範例二：持續偵測/var/log/messages的內容</span>
[root@www ~]# <span class="term_command">tail -f /var/log/messages</span>
  <span class="term_note">&lt;==要等到輸入[crtl]-c之後才會離開tail這個指令的偵測！</span>
</pre></td></tr></table>

		<p>有 head 自然就有 tail ( 尾巴 ) 囉！沒錯！這個 tail 的用法跟 head 
		的用法差不多類似，只是顯示的是後面幾行就是了！預設也是顯示十行，若要顯示非十行，就加 
		-n number 的選項即可。</p>

		<p>範例一的內容就有趣啦！其實與head -n -xx有異曲同工之妙。當下達『tail -n +100 /etc/man.config』
		代表該檔案從100行以後都會被列出來，同樣的，在man.config共有141行，因此第100~141行就會被列出來啦！
		前面的99行都不會被顯示出來喔！</p>

		<p>至於範例二中，由於/var/log/messages隨時會有資料寫入，你想要讓該檔案有資料寫入時就立刻顯示到螢幕上，
		就利用 -f 這個選項，他可以一直偵測/var/log/messages這個檔案，新加入的資料都會被顯示到螢幕上。
		直到你按下[crtl]-c才會離開tail的偵測喔！</p>

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">
假如我想要顯示 /etc/man.config 的第 11 到第 20 行呢？
</div>
答：<div class="block2">
這個應該不算難，想一想，在第 11 到第 20 行，那麼我取前 20 行，再取後十行，所以結果就是：『 
head -n 20 /etc/man.config | tail -n 10 』，這樣就可以得到第 11 到第 20 行之間的內容了！
但是裡面涉及到管線命令，需要在第三篇的時候才講的到！
</div>
</td></tr></table><br />
	</div>

	<hr /><a name="od"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">非純文字檔： od</span><br />
	<div class="block2">
		<p>我們上面提到的，都是在查閱純文字檔的內容。
		那麼萬一我們想要查閱非文字檔，舉例來說，例如 /usr/bin/passwd 這個執行檔的內容時，
		又該如何去讀出資訊呢？事實上，由於執行檔通常是 binary file ，使用上頭提到的指令來讀取他的內容時，
		確實會產生類似亂碼的資料啊！那怎麼辦？沒關係，我們可以利用 od 這個指令來讀取喔！</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">od [-t TYPE] 檔案</span>
<span class="term_say">選項或參數：
-t  ：後面可以接各種『類型 (TYPE)』的輸出，例如：
      a       ：利用預設的字元來輸出；
      c       ：使用 ASCII 字元來輸出
      d[size] ：利用十進位(decimal)來輸出資料，每個整數佔用 size bytes ；
      f[size] ：利用浮點數值(floating)來輸出資料，每個數佔用 size bytes ；
      o[size] ：利用八進位(octal)來輸出資料，每個整數佔用 size bytes ；
      x[size] ：利用十六進位(hexadecimal)來輸出資料，每個整數佔用 size bytes ；</span>

<span class="term_hd">範例一：請將/usr/bin/passwd的內容使用ASCII方式來展現！</span>
[root@www ~]# <span class="term_command">od -t c /usr/bin/passwd</span>
0000000 177   E   L   F 001 001 001  \0  \0  \0  \0  \0  \0  \0  \0  \0
0000020 002  \0 003  \0 001  \0  \0  \0 260 225 004  \b   4  \0  \0  \0
0000040 020   E  \0  \0  \0  \0  \0  \0   4  \0      \0  \a  \0   (  \0
0000060 035  \0 034  \0 006  \0  \0  \0   4  \0  \0  \0   4 200 004  \b
0000100   4 200 004  \b 340  \0  \0  \0 340  \0  \0  \0 005  \0  \0  \0
<span class="term_say">.....(後面省略)....
# 最左邊第一欄是以 8 進位來表示bytes數。以上面範例來說，第二欄0000020代表開頭是
# 第 16 個 byes (2x8) 的內容之意。</span>

<span class="term_hd">範例二：請將/etc/issue這個檔案的內容以8進位列出儲存值與ASCII的對照表</span>
[root@www ~]# <span class="term_command">od -t oCc /etc/issue</span>
0000000 103 145 156 164 117 123 040 162 145 154 145 141 163 145 040 065
          C   e   n   t   O   S       r   e   l   e   a   s   e       5
0000020 056 062 040 050 106 151 156 141 154 051 012 113 145 162 156 145
          .   2       (   F   i   n   a   l   )  \n   K   e   r   n   e
0000040 154 040 134 162 040 157 156 040 141 156 040 134 155 012 012
          l       \   r       o   n       a   n       \   m  \n  \n
0000057
<span class="term_say"># 如上所示，可以發現每個字元可以對應到的數值為何！
# 例如e對應的記錄數值為145，轉成十進位：1x8^2+4x8+5=101。</span>

</pre></td></tr></table>

		<p>利用這個指令，可以將 data file 或者是 binary file 的內容資料給他讀出來喔！
		雖然讀出的來數值預設是使用非文字檔，亦即是 16 進位的數值來顯示的，
		不過，我們還是可以透過 -t c 的選項與參數來將資料內的字元以 ASCII 類型的字元來顯示，
		雖然對於一般使用者來說，這個指令的用處可能不大，但是對於工程師來說，
		這個指令可以將 binary file 的內容作一個大致的輸出，他們可以看得出東西的啦～ ^_^</p>

		<p>如果對純文字檔使用這個指令，你甚至可以發現到 ASCII 與字元的對照表！非常有趣！
		例如上述的範例二，你可以發現到每個英文字 e 對照到的數字都是 145，轉成十進位你就能夠發現那是 101 囉！
		如果你有任何程式語言的書，拿出來對照一下 ASCII 的對照表，就能夠發現真是正確啊！呵呵！</p>
	</div>

	<hr /><a name="touch"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">修改檔案時間或建置新檔： touch</span><br />
	<div class="block2">

		<p>我們在 <a href="#ls">ls 這個指令的介紹</a>時，有稍微提到每個檔案在linux底下都會記錄許多的時間參數，
		其實是有三個主要的變動時間，那麼三個時間的意義是什麼呢？</p>

		<ul class="text_import2">
		<li><b>modification time (mtime)</b>：<br />
		當該檔案的『內容資料』變更時，就會更新這個時間！內容資料指的是檔案的內容，而不是檔案的屬性或權限喔！<br /><br /></li>

		<li><b>status time (ctime)</b>：<br />

		當該檔案的『狀態 (status)』改變時，就會更新這個時間，舉例來說，像是權限與屬性被更改了，都會更新這個時間啊。
		<br /><br /></li>

		<li><b>access time (atime)</b>：<br />
		當『該檔案的內容被取用』時，就會更新這個讀取時間 (access)。舉例來說，我們使用 cat 去讀取 /etc/man.config ，
		就會更新該檔案的 atime 了。</li></ul>

		<p>這是個挺有趣的現象，舉例來說，我們來看一看你自己的 /etc/man.config 這個檔案的時間吧！</p>

<table class="term"><tr><td class="term"><pre>

[root@www ~]# <span class="term_command">ls -l /etc/man.config</span>
-rw-r--r-- 1 root root 4617 Jan  6  2007 /etc/man.config
[root@www ~]# <span class="term_command">ls -l --time=atime /etc/man.config</span>
-rw-r--r-- 1 root root 4617 Sep 25 17:54 /etc/man.config
[root@www ~]# <span class="term_command">ls -l --time=ctime /etc/man.config</span>
-rw-r--r-- 1 root root 4617 Sep  4 18:03 /etc/man.config
</pre></td></tr></table>

		<p>看到了嗎？<span class="text_import2">在預設的情況下，ls 顯示出來的是該檔案的
		mtime ，也就是這個檔案的內容上次被更動的時間</span>。
		至於鳥哥的系統是在 9 月 4 號的時候安裝的，因此，這個檔案被產生導致狀態被更動的時間就回溯到那個時間點了(ctime)！
		而還記得剛剛我們使用的範例當中，有使用到man.config這個檔案啊，所以啊，他的 atime 就會變成剛剛使用的時間了！</p>

		<p>檔案的時間是很重要的，因為，如果檔案的時間誤判的話，可能會造成某些程式無法順利的運作。
		OK！那麼萬一我發現了一個檔案來自未來，該如何讓該檔案的時間變成『現在』的時刻呢？
		很簡單啊！就用『touch』這個指令即可！</p>

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tr><td><b>Tips:</b><br /><span style="color : #009000"><font size="-1">		嘿嘿！不要懷疑系統時間會『來自未來』喔！很多時候會有這個問題的！舉例來說在安裝過後系統時間可能會被改變！
		因為台灣時區在國際標準時間『格林威治時間, GMT』的右邊，所以會比較早看到陽光，也就是說，台灣時間比GMT時間快了八小時！
		如果安裝行為不當，我們的系統可能會有八小時快轉，你的檔案就有可能來自八小時候了。<br /><br />
		至於某些情況下，由於BIOS的設定錯誤，導致系統時間跑到未來時間，並且你又建立了某些檔案。
		等你將時間改回正確的時間時，該檔案不就變成來自未來了？^_^
		</font></span></td><td><img src="/images/vbird_face.gif" alt="鳥哥的圖示" title="鳥哥的圖示" /></td></tr></table></div>
<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">touch [-acdmt] 檔案</span>

<span class="term_say">選項與參數：
-a  ：僅修訂 access time；
-c  ：僅修改檔案的時間，若該檔案不存在則不建立新檔案；
-d  ：後面可以接欲修訂的日期而不用目前的日期，也可以使用 --date="日期或時間"
-m  ：僅修改 mtime ；
-t  ：後面可以接欲修訂的時間而不用目前的時間，格式為[YYMMDDhhmm]</span>

<span class="term_hd">範例一：新建一個空的檔案並觀察時間</span>
[root@www ~]# <span class="term_command">cd /tmp</span>
[root@www tmp]# <span class="term_command">touch testtouch</span>
[root@www tmp]# <span class="term_command">ls -l testtouch</span>
-rw-r--r-- 1 root root <span class="term_write">0</span> Sep 25 21:09 testtouch

<span class="term_say"># 注意到，這個檔案的大小是 0 呢！在預設的狀態下，如果 touch 後面有接檔案，
# 則該檔案的三個時間 (atime/ctime/mtime) 都會更新為目前的時間。若該檔案不存在，
# 則會主動的建立一個新的空的檔案喔！例如上面這個例子！</span>

<span class="term_hd">範例二：將 ~/.bashrc 複製成為 bashrc，假設複製完全的屬性，檢查其日期</span>
[root@www tmp]# <span class="term_command">cp -a ~/.bashrc bashrc</span>
[root@www tmp]# <span class="term_command">ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc</span>
-rw-r--r-- 1 root root 176 Jan  6  2007 bashrc  <span class="term_note">&lt;==這是 mtime</span>
-rw-r--r-- 1 root root 176 Sep 25 21:11 bashrc  <span class="term_note">&lt;==這是 atime</span>

-rw-r--r-- 1 root root 176 Sep 25 21:12 bashrc  <span class="term_note">&lt;==這是 ctime</span>
</pre></td></tr></table>

		<p>在上面這個案例當中我們使用了『ll』這個指令(兩個英文L的小寫)，這個指令其實就是『ls -l』的意思，
		ll本身不存在，是被『做出來』的一個命令別名。相關的<a 
		href="/linux_basic/0320bash.php#alias">命令別名我們會在bash章節</a>當中詳談的，這裡先知道ll="ls -l"即可。
		至於分號『 ; 』則代表連續指令的下達啦！你可以在一行指令當中寫入多重指令，
		這些指令可以『依序』執行。由上面的指令我們會知道ll那一行有三個指令被下達在同一行中。</p>

		<p>至於執行的結果當中，我們可以發現資料的內容與屬性是被複製過來的，因此檔案內容時間(mtime)與原本檔案相同。
		但是由於這個檔案是剛剛被建立的，因此狀態(ctime)與讀取時間就便呈現在的時間啦！
		那如果你想要變更這個檔案的時間呢？可以這樣做：</p>

<table class="term"><tr><td class="term"><pre>
<span class="term_hd">範例三：修改案例二的 bashrc 檔案，將日期調整為兩天前</span>

[root@www tmp]# <span class="term_command">touch -d "2 days ago" bashrc</span>
[root@www tmp]# <span class="term_command">ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc</span>
-rw-r--r-- 1 root root 176 Sep 23 21:23 bashrc
-rw-r--r-- 1 root root 176 Sep 23 21:23 bashrc
-rw-r--r-- 1 root root 176 Sep 25 21:23 bashrc
<span class="term_say"># 跟上個範例比較看看，本來是 25 日的變成了 23 日了 (atime/mtime)～
# 不過， ctime 並沒有跟著改變喔！</span>

<span class="term_hd">範例四：將上個範例的 bashrc 日期改為 2007/09/15 2:02</span>
[root@www tmp]# <span class="term_command">touch -t 0709150202 bashrc</span>
[root@www tmp]# <span class="term_command">ll bashrc; ll --time=atime bashrc; ll --time=ctime bashrc</span>

-rw-r--r-- 1 root root 176 Sep 15  2007 bashrc
-rw-r--r-- 1 root root 176 Sep 15  2007 bashrc
-rw-r--r-- 1 root root 176 Sep 25 21:25 bashrc
<span class="term_say"># 注意看看，日期在 atime 與 mtime 都改變了，但是 ctime 則是記錄目前的時間！</span>
</pre></td></tr></table>

		<p>透過 touch 這個指令，我們可以輕易的修訂檔案的日期與時間。並且也可以建立一個空的檔案喔！
		不過，要注意的是，即使我們複製一個檔案時，複製所有的屬性，但也沒有辦法複製 ctime 這個屬性的。
		ctime 可以記錄這個檔案最近的狀態 (status) 被改變的時間。無論如何，還是要告知大家，
		我們平時看的檔案屬性中，比較重要的還是屬於那個 mtime 啊！我們關心的常常是這個檔案的『內容』
		是什麼時候被更動的說～瞭乎？</p>

		<p>無論如何， touch 這個指令最常被使用的情況是：</p><ul class="text_import2">
		<li>建立一個空的檔案；</li>
		<li>將某個檔案日期修訂為目前 (mtime 與 atime)</li></ul>

	</div>
</div>


<hr /><a name="fileperm"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">檔案與目錄的預設權限與隱藏權限</span><br />
<div class="block1">
	<p>由<a href="/linux_basic/0210filepermission.php">第六章、Linux檔案權限</a>的內容我們可以知道一個檔案有若干個屬性，
	包括讀寫執行(r, w, x)等基本權限，及是否為目錄 (d) 與檔案 (-) 或者是連結檔 (l) 等等的屬性！
	要修改屬性的方法在前面也約略提過了(<a href="/linux_basic/0210filepermission.php#chgrp">chgrp</a>,
	<a href="/linux_basic/0210filepermission.php#chown">chown</a>, <a href="/linux_basic/0210filepermission.php#chmod">chmod</a>)
	，本小節會再加強補充一下！</p>

	<p>除了基本r, w, x權限外，在Linux的Ext2/Ext3檔案系統下，我們還可以設定其他的系統隱藏屬性，
	這部份可使用 <a href="#chattr">chattr</a> 來設定，而以 <a href="#lsattr">lsattr</a> 
	來查看，最重要的屬性就是可以設定其不可修改的特性！讓連檔案的擁有者都不能進行修改！
	這個屬性可是相當重要的，尤其是在安全機制上面 (security)！</p>

	<p>首先，先來複習一下上一章談到的權限概念，將底下的例題看一看先：</p>

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">

你的系統有個一般身份使用者 dmtsai，他的群組屬於 users，他的家目錄在 /home/dmtsai，
你是root，你想將你的 ~/.bashrc 複製給他，可以怎麼作？
</div>
答：<div class="block2">
由上一章的權限概念我們可以知道 root 雖然可以將這個檔案複製給 dmtsai，不過這個檔案在 dmtsai
的家目錄中卻可能讓 dmtsai 沒有辦法讀寫(因為該檔案屬於 root 的嘛！而 dmtsai 又不能使用 chown 之故)。
此外，我們又擔心覆蓋掉 dmtsai 自己的 .bashrc 設定檔，因此，我們可以進行如下的動作喔：<br />
<blockquote style="font-family: '細明體'">
複製檔案： cp ~/.bashrc ~dmtsai/bashrc<br />
修改屬性： chown dmtsai:users ~dmtsai/bashrc
</blockquote>
</div>
</td></tr></table><br />

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">

我想在 /tmp 底下建立一個目錄，這個目錄名稱為 chapter7_1 ，並且這個目錄擁有者為 dmtsai，
群組為 users ，此外，任何人都可以進入該目錄瀏覽檔案，不過除了 dmtsai 之外，其他人都不能修改該目錄下的檔案。
</div>
答：<div class="block2">
因為除了 dmtsai 之外，其他人不能修改該目錄下的檔案，所以整個目錄的權限應該是 drwxr-xr-x 才對！
因此你應該這樣做：
<blockquote style="font-family: '細明體'">
建立目錄： mkdir /tmp/chapter7_1<br />
修改屬性： chown -R dmtsai:users /tmp/chapter7_1<br />
修改權限： chmod -R 755 /tmp/chapter7_1
</blockquote>
</div>
</td></tr></table>

	<p>在上面這個例題當中，如果你知道 755 那個分數是怎麼計算出來的，那麼你應該對於權限有一定程度的概念了。
	如果你不知道 755 怎麼來的？那麼...趕快回去前一章看看 <a href="/linux_basic/0210filepermission.php#chmod">chmod</a> 
	那個指令的介紹部分啊！這部分很重要喔！你得要先清楚的瞭解到才行～否則就進行不下去囉～
	假設你對於權限都認識的差不多了，那麼底下我們就要來談一談，『<span 
	class="text_import2">新增一個檔案或目錄時，預設的權限是什麼</span>？』這個議題！<br /><br /></p>

	<hr /><a name="umask"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">檔案預設權限：umask</span><br />
	<div class="block2">
		<p>OK！那麼現在我們知道如何建立或者是改變一個目錄或檔案的屬性了，不過，
		你知道當你建立一個<span class="text_import2">新的檔案或目錄</span>時，他的預設權限會是什麼嗎？呵呵！那就與 umask 
		這個玩意兒有關了！那麼 umask 是在搞什麼呢？基本上， umask 就是指定
		『<span class="text_import2">目前使用者在建立檔案或目錄時候的權限預設值</span>』，
		那麼如何得知或設定 umask 呢？他的指定條件以底下的方式來指定：</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">umask</span>

0022             <span class="term_note">&lt;==與一般權限有關的是後面三個數字！</span>
[root@www ~]# <span class="term_command">umask -S</span>
u=rwx,g=rx,o=rx
</pre></td></tr></table>

		<p>查閱的方式有兩種，一種可以直接輸入 umask ，就可以看到數字型態的權限設定分數，
		一種則是加入 -S (Symbolic) 這個選項，就會以符號類型的方式來顯示出權限了！
		奇怪的是，怎麼 umask 會有四組數字啊？不是只有三組嗎？是沒錯啦。
		第一組是特殊權限用的，我們先不要理他，所以先看後面三組即可。</p>

		<p>在預設權限的屬性上，目錄與檔案是不一樣的。從第六章我們知道 x 權限對於目錄是非常重要的！
		但是一般檔案的建立則不應該有執行的權限，因為一般檔案通常是用在於資料的記錄嘛！當然不需要執行的權限了。
		因此，預設的情況如下：</p>

		<ul>
		<li>若使用者建立為『檔案』則預設『沒有可執行( x )權限』，亦即只有 rw 這兩個項目，也就是最大為 
			666 分，預設權限如下：<br />
			<span class="text_import1">-rw-rw-rw-</span><br /><br /></li>
		<li>若使用者建立為『目錄』，則由於 x 與是否可以進入此目錄有關，因此預設為所有權限均開放，亦即為 
			777 分，預設權限如下：<br />
			<span class="text_import1">drwxrwxrwx</span></li></ul>

		<p>要注意的是，umask 的分數指的是『<span class="text_import2">該預設值需要減掉的權限</span>！』因為 
		r、w、x 分別是 4、2、1 分，所以囉！也就是說，當要拿掉能寫的權限，就是輸入 2 
		分，而如果要拿掉能讀的權限，也就是 4 分，那麼要拿掉讀與寫的權限，也就是 6 
		分，而要拿掉執行與寫入的權限，也就是 3 分，這樣瞭解嗎？請問你， 5 分是什麼？呵呵！
		就是讀與執行的權限啦！</p>

		<p>如果以上面的例子來說明的話，因為 umask 為 022 ，所以 user 
		並沒有被拿掉任何權限，不過 group 與 others 的權限被拿掉了 2 (也就是 w 這個權限)，那麼當使用者：</p>

		<ul class="text_import2" style="font-family:'細明體'">
		<li>建立檔案時：(-rw-rw-rw-) - (-----w--w-) ==&gt; -rw-r--r--</li>
		<li>建立目錄時：(drwxrwxrwx) - (d----w--w-) ==&gt; drwxr-xr-x</li></ul>

		不相信嗎？我們就來測試看看吧！<br />

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">umask</span>
0022
[root@www ~]# <span class="term_command">touch test1</span>
[root@www ~]# <span class="term_command">mkdir test2</span>
[root@www ~]# <span class="term_command">ll </span>

<span class="term_write">-rw-r--r--</span> 1 root root     0 Sep 27 00:25 test1
<span class="term_write">drwxr-xr-x</span> 2 root root  4096 Sep 27 00:25 test2
</pre></td></tr></table>

		<p>呵呵！瞧見了吧！確定新建檔案的權限是沒有錯的。<br /><br /></p>

		<hr /><ul class="list1"><li class="text_import1">umask的利用與重要性：專題製作</li></ul>
		<p>想像一個狀況，如果你跟你的同學在同一部主機裡面工作時，因為你們兩個正在進行同一個專題，
		老師也幫你們兩個的帳號建立好了相同群組的狀態，並且將 /home/class/ 目錄做為你們兩個人的專題目錄。
		想像一下，有沒有可能你所製作的檔案你的同學無法編輯？果真如此的話，那就傷腦筋了！</p>

		<p>這個問題很常發生啊！舉上面的案例來看就好了，你看一下 test1 的權限是幾分？ 644 呢！意思是『<span 
		class="text_import2">如果 umask  訂定為 022 ，那新建的資料只有使用者自己具有 w 的權限，
		同群組的人只有 r 這個可讀的權限而已，並無法修改喔！</span>』這樣要怎麼共同製作專題啊！您說是吧！</p>

		<p>所以，當我們需要新建檔案給同群組的使用者共同編輯時，那麼 umask 的群組就不能拿掉 2 這個 w 的權限！
		所以囉， umask 就得要是 002 之類的才可以！這樣新建的檔案才能夠是 -rw-rw-r-- 的權限模樣喔！
		那麼如何設定 umask 呢？簡單的很，直接在 umask 後面輸入 002 就好了！</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">umask 002</span>
[root@www ~]# <span class="term_command">touch test3</span>

[root@www ~]# <span class="term_command">mkdir test4</span>
[root@www ~]# <span class="term_command">ll </span>
<span class="term_write">-rw-rw-r--</span> 1 root root     0 Sep 27 00:36 test3
<span class="term_write">drwxrwxr-x</span> 2 root root  4096 Sep 27 00:36 test4
</pre></td></tr></table>

		<p>所以說，這個 umask 對於新建檔案與目錄的預設權限是很有關係的！這個概念可以用在任何伺服器上面，
		尤其是未來在你架設檔案伺服器 (file server) ，舉例來說，
		<a href="/linux_server/0370samba.php">SAMBA Server</a> 或者是 
		<a href="/linux_server/0410vsftpd.php">FTP server</a> 時，
		都是很重要的觀念！這牽涉到你的使用者是否能夠將檔案進一步利用的問題喔！不要等閒視之！</p>

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">
假設你的 umask 為 003 ，請問該 umask 情況下，建立的檔案與目錄權限為？
</div>
答：<div class="block2">
umask 為 003 ，所以拿掉的權限為 --------wx，因此：<br />
<blockquote style="font-family:'細明體'">
檔案： (-rw-rw-rw-) - (--------wx) = -rw-rw-r--<br />
目錄： (drwxrwxrwx) - (--------wx) = drwxrwxr--</blockquote>
</div>
</td></tr></table><br />

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tr><td><b>Tips:</b><br /><span style="color : #009000"><font size="-1">		關於 umask 與權限的計算方式中，教科書喜歡使用二進位的方式來進行 AND 與 NOT 的計算，
		不過，鳥哥還是比較喜歡使用符號方式來計算～聯想上面比較容易一點～<br /><br />

		但是，有的書籍或者是 BBS 上面的朋友，喜歡使用檔案預設屬性 666 與目錄預設屬性
		777 來與 umask 進行相減的計算～這是不好的喔！以上面例題來看，
		如果使用預設屬性相加減，則檔案變成：666-003=663，亦即是 -rw-rw--wx ，這可是完全不對的喔！
		想想看，原本檔案就已經去除 x 的預設屬性了，怎麼可能突然間冒出來了？
		所以，這個地方得要特別小心喔！
		</font></span></td><td><img src="/images/vbird_face.gif" alt="鳥哥的圖示" title="鳥哥的圖示" /></td></tr></table></div>
		<p>在預設的情況中， root 的 umask 會拿掉比較多的屬性，root 的 umask 預設是 022 ，
		這是基於安全的考量啦～至於一般身份使用者，通常他們的 umask 為 002 ，亦即保留同群組的寫入權力！
		其實，關於預設 umask 的設定可以參考 /etc/bashrc 這個檔案的內容，不過，不建議修改該檔案，
		你可以參考<a href="/linux_basic/0320bash.php#settings_bashrc_bashrc">第十一章 bash shell 提到的環境參數設定檔</a>
		(~/.bashrc) 的說明！</p>

	</div>

	<hr /><a name="attr"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">檔案隱藏屬性：</span><br />
	<div class="block2">
		<p>什麼？檔案還有隱藏屬性？光是那九個權限就快要瘋掉了，竟然還有隱藏屬性，真是要命～
		但是沒辦法，就是有檔案的隱藏屬性存在啊！不過，這些隱藏的屬性確實對於系統有很大的幫助的～
		尤其是在系統安全 (Security) 上面，重要的緊呢！<span 
		class="text_import2">不過要先強調的是，底下的chattr指令只能在Ext2/Ext3的檔案系統上面生效</span>，
		其他的檔案系統可能就無法支援這個指令了。底下我們就來談一談如何設定與檢查這些隱藏的屬性吧！<br /><br /></p>

		<a name="chattr"></a>
		<hr /><ul class="list1"><li class="text_import1">chattr (設定檔案隱藏屬性)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">chattr [+-=][ASacdistu] 檔案或目錄名稱</span>
<span class="term_say">選項與參數：
+   ：增加某一個特殊參數，其他原本存在參數則不動。
-   ：移除某一個特殊參數，其他原本存在參數則不動。
=   ：設定一定，且僅有後面接的參數

A  ：當設定了 A 這個屬性時，若你有存取此檔案(或目錄)時，他的存取時間 atime
     將不會被修改，可避免I/O較慢的機器過度的存取磁碟。這對速度較慢的電腦有幫助
S  ：一般檔案是非同步寫入磁碟的(原理請參考<a href="/linux_basic/0160startlinux.php#sync">第五章sync</a>的說明)，如果加上 S 這個
     屬性時，當你進行任何檔案的修改，該更動會『同步』寫入磁碟中。
<span style="text-decoration:underline">a  ：當設定 a 之後，這個檔案將只能增加資料，而不能刪除也不能修改資料，只有root 
     才能設定這個屬性。 </span>
c  ：這個屬性設定之後，將會自動的將此檔案『壓縮』，在讀取的時候將會自動解壓縮，
     但是在儲存的時候，將會先進行壓縮後再儲存(看來對於大檔案似乎蠻有用的！)
d  ：當 dump 程序被執行的時候，設定 d 屬性將可使該檔案(或目錄)不會被 dump 備份
<span style="text-decoration:underline">i  ：這個 i 可就很厲害了！他可以讓一個檔案『不能被刪除、改名、設定連結也無法
     寫入或新增資料！』對於系統安全性有相當大的助益！只有 root 能設定此屬性</span>
s  ：當檔案設定了 s 屬性時，如果這個檔案被刪除，他將會被完全的移除出這個硬碟
     空間，所以如果誤刪了，完全無法救回來了喔！
u  ：與 s 相反的，當使用 u 來設定檔案時，如果該檔案被刪除了，則資料內容其實還
     存在磁碟中，可以使用來救援該檔案喔！
注意：屬性設定常見的是 a 與 i 的設定值，而且很多設定值必須要身為 root 才能設定</span>

<span class="term_hd">範例：請嘗試到/tmp底下建立檔案，並加入 i 的參數，嘗試刪除看看。</span>

[root@www ~]# <span class="term_command">cd /tmp</span>
[root@www tmp]# <span class="term_command">touch attrtest    </span> <span class="term_note">&lt;==建立一個空檔案</span>
[root@www tmp]# <span class="term_command">chattr +i attrtest</span> <span class="term_note">&lt;==給予 i 的屬性</span>
[root@www tmp]# <span class="term_command">rm attrtest       </span> <span class="term_note">&lt;==嘗試刪除看看</span>

rm: remove write-protected regular empty file `attrtest'? <span class="term_write">y</span>
rm: cannot remove `attrtest': Operation not permitted  <span class="term_note">&lt;==操作不許可</span>
<span class="term_say"># 看到了嗎？呼呼！連 root 也沒有辦法將這個檔案刪除呢！趕緊解除設定！</span>

<span class="term_hd">範例：請將該檔案的 i 屬性取消！</span>
[root@www tmp]# <span class="term_command">chattr -i attrtest</span>
</pre></td></tr></table>

		<p>這個指令是很重要的，尤其是在系統的資料安全上面！由於這些屬性是隱藏的性質，所以需要以 
		<a href="#lsattr">lsattr</a> 才能看到該屬性呦！其中，個人認為最重要的當屬 +i 與 +a
		這個屬性了。+i 可以讓一個檔案無法被更動，對於需要強烈的系統安全的人來說，
		真是相當的重要的！裡頭還有相當多的屬性是需要 root 才能設定的呢！</p>

		<p>此外，如果是 log file 這種的登錄檔，就更需要 +a 這個可以增加，但是不能修改舊有的資料與刪除的參數了！怎樣？很棒吧！
		未來提到<a href="/linux_basic/0570syslog.php">登錄檔 (十九章)</a> 的認知時，我們再來聊一聊如何設定他吧！<br /><br /></p>

		<a name="lsattr"></a>
		<hr /><ul class="list1"><li class="text_import1">lsattr (顯示檔案隱藏屬性)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">lsattr [-adR] 檔案或目錄</span>

<span class="term_say">選項與參數：
-a ：將隱藏檔的屬性也秀出來；
-d ：如果接的是目錄，僅列出目錄本身的屬性而非目錄內的檔名；
-R ：連同子目錄的資料也一併列出來！ </span>

[root@www tmp]# <span class="term_command">chattr +aij attrtest</span>
[root@www tmp]# <span class="term_command">lsattr attrtest</span>
----ia---j--- attrtest
</pre></td></tr></table>

		<p>使用 chattr 設定後，可以利用 lsattr 來查閱隱藏的屬性。不過，
		這兩個指令在使用上必須要特別小心，否則會造成很大的困擾。例如：某天你心情好，突然將 
		/etc/shadow 這個重要的密碼記錄檔案給他設定成為具有 i 的屬性，那麼過了若干天之後，
		你突然要新增使用者，卻一直無法新增！別懷疑，趕快去將 i 的屬性拿掉吧！</p>
	</div>

	<hr /><a name="suid_sgid_sbit"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">檔案特殊權限：
	SUID, SGID, SBIT</span><br />
	<div class="block2">
		<p>我們前面一直提到關於檔案的重要權限，那就是 rwx 這三個讀、寫、執行的權限。
		但是，眼尖的朋友們在<a href="/linux_basic/0210filepermission.php#dir_tree">第六章的目錄樹章節</a>中，
		一定注意到了一件事，那就是，怎麼我們的 /tmp 權限怪怪的？
		還有，那個 /usr/bin/passwd 也怪怪的？怎麼回事啊？看看先：</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">ls -ld /tmp ; ls -l /usr/bin/passwd</span>
drwxrwxrw<span class="term_write">t</span> 7 root root 4096 Sep 27 18:23 /tmp
-rw<span class="term_write">s</span>r-xr-x 1 root root 22984 Jan  7  2007 /usr/bin/passwd

</pre></td></tr></table>

		<p>不是應該只有 rwx 嗎？還有其他的特殊權限( s 跟 t )啊？啊.....頭又開始昏了～ @_@
		因為 s 與 t 這兩個權限的意義與<a href="/linux_basic/0410accountmanager.php">系統的帳號 (第十四章)</a>及<a
		href="/linux_basic/0440processcontrol.php">系統的程序(process, 第十七章)</a>較為相關，
		所以等到後面的章節談完後你才會比較有概念！底下的說明先看看就好，如果看不懂也沒有關係，
		先知道s放在哪裡稱為SUID/SGID以及如何設定即可，等系統程序章節讀完後，再回來看看喔！<br /><br /></p>

		<a name="suid"></a>
		<hr /><ul class="list1"><li class="text_import1">Set UID</li></ul>
		<p>當 s 這個標誌出現在檔案擁有者的 x 權限上時，例如剛剛提到的 /usr/bin/passwd 這個檔案的權限狀態：『<span
		class="text_import2">-rw<b>s</b>r-xr-x</span>』，此時就被稱為 Set UID，簡稱為 SUID 的特殊權限。
		那麼SUID的權限對於一個檔案的特殊功能是什麼呢？基本上SUID有這樣的限制與功能：</p>

		<ul class="text_import2">
		<li>SUID 權限僅對二進位程式(binary program)有效；</li>
		<li>執行者對於該程式需要具有 x  的可執行權限；</li>
		<li>本權限僅在執行該程式的過程中有效 (run-time)；</li>
		<li>執行者將具有該程式擁有者 (owner) 的權限。</li>
		</ul>

		<p>講這麼硬的東西你可能對於 SUID 還是沒有概念，沒關係，我們舉個例子來說明好了。
		我們的 Linux 系統中，所有帳號的密碼都記錄在 /etc/shadow 這個檔案裡面，這個檔案的權限為：『<span
		class="text_import2">-r-------- 1 root root</span>』，意思是這個檔案僅有root可讀且僅有root可以強制寫入而已。
		既然這個檔案僅有 root 可以修改，那麼鳥哥的 vbird 這個一般帳號使用者能否自行修改自己的密碼呢？
		你可以使用你自己的帳號輸入『passwd』這個指令來看看，嘿嘿！一般使用者當然可以修改自己的密碼了！</p>

		<p>唔！有沒有衝突啊！明明 /etc/shadow 就不能讓 vbird 這個一般帳戶去存取的，為什麼 vbird 還能夠修改這個檔案內的密碼呢？
		這就是 SUID 的功能啦！藉由上述的功能說明，我們可以知道</p>

		<ol>
		<li>vbird 對於 /usr/bin/passwd 這個程式來說是具有 x 權限的，表示 vbird 能執行 passwd；</li>
		<li>passwd 的擁有者是 root 這個帳號；</li>

		<li>vbird 執行 passwd 的過程中，會『暫時』獲得 root 的權限；</li>
		<li>/etc/shadow 就可以被 vbird 所執行的 passwd 所修改。</li></ol>

		<p>但如果 vbird 使用 cat 去讀取 /etc/shadow 時，他能夠讀取嗎？因為 cat 不具有 SUID 的權限，所以 vbird 執行 『cat /etc/shadow』
		時，是不能讀取 /etc/shadow 的。我們用一張示意圖來說明如下：</p>

		<center><img src="0220filemanager/suid.gif" alt="SUID程式執行的過程示意圖" 
		title="SUID程式執行的過程示意圖" border="1" /><br />
		圖4.4.1、SUID程式執行的過程示意圖<br /></center>

		<p>另外，<span class="text_import2">SUID 僅可用在binary program 上，
		不能夠用在 shell script 上面</span>！這是因為 shell script 只是將很多的 binary 
		執行檔叫進來執行而已！所以 SUID 的權限部分，還是得要看 shell script 呼叫進來的程式的設定，
		而不是 shell script 本身。當然，SUID 對於目錄也是無效的～這點要特別留意。<br /><br /></p>

		<a name="sgid"></a>
		<hr /><ul class="list1"><li class="text_import1">Set GID</li></ul>

		<p>當 s 標誌在檔案擁有者的 x 項目為 SUID，那 s 在群組的 x 時則稱為 Set GID, SGID 囉！是這樣沒錯！^_^。
		舉例來說，你可以用底下的指令來觀察到具有 SGID 權限的檔案喔：</p>

<table class="term"><tr><td class="term"><pre>

[root@www ~]# <span class="term_command">ls -l /usr/bin/locate</span>
<span class="term_write">-rwx--s--x</span> 1 root slocate 23856 Mar 15  2007 /usr/bin/locate
</pre></td></tr></table>

		<p>與 SUID 不同的是，SGID 可以針對檔案或目錄來設定！如果是對檔案來說， SGID 有如下的功能：</p>

		<ul class="text_import2">
		<li>SGID 對二進位程式有用；</li>

		<li>程式執行者對於該程式來說，需具備 x 的權限；</li>
		<li>執行者在執行的過程中將會獲得該程式群組的支援！</li>
		</ul>

		<p>舉例來說，上面的 /usr/bin/locate 這個程式可以去搜尋 /var/lib/mlocate/mlocate.db 這個檔案的內容 (詳細說明會在下節講述)，
		mlocate.db 的權限如下：</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">ll /usr/bin/locate /var/lib/mlocate/mlocate.db</span>

<span class="term_write">-rwx--s--x</span> 1 root <span class="term_write">slocate</span>   23856 Mar 15  2007 /usr/bin/locate
<span class="term_write">-rw-r-----</span> 1 root <span class="term_write">slocate</span> 3175776 Sep 28 04:02 /var/lib/mlocate/mlocate.db
</pre></td></tr></table>

		<p>與 SUID 非常的類似，若我使用 vbird 這個帳號去執行 locate 時，那 vbird 將會取得 slocate 群組的支援，
		因此就能夠去讀取 mlocate.db 啦！非常有趣吧！</p>

		<p>除了 binary program 之外，事實上 SGID 也能夠用在目錄上，這也是非常常見的一種用途！
		當一個目錄設定了 SGID 的權限後，他將具有如下的功能：</p>

		<ul class="text_import2">
		<li>使用者若對於此目錄具有 r 與 x 的權限時，該使用者能夠進入此目錄；</li>
		<li>使用者在此目錄下的有效群組(effective group)將會變成該目錄的群組；</li>
		<li>用途：若使用者在此目錄下具有 w 的權限(可以新建檔案)，則使用者所建立的新檔案，該新檔案的群組與此目錄的群組相同。</li>
		</ul>

		<p>SGID 對於專案開發來說是非常重要的！因為這涉及群組權限的問題，您可以參考一下本章後續<a
		href="#situation1">情境模擬的案例</a>，應該就能夠對於 SGID 有一些瞭解的！^_^<br /><br /></p>

		<a name="sbit"></a>
		<hr /><ul class="list1"><li class="text_import1">Sticky Bit</li></ul>
		<p>這個 Sticky Bit, SBIT 目前只針對目錄有效，對於檔案已經沒有效果了。
		SBIT 對於目錄的作用是：</p>

		<ul class="text_import2">

		<li>當使用者對於此目錄具有 w, x 權限，亦即具有寫入的權限時；</li>
		<li>當使用者在該目錄下建立檔案或目錄時，僅有自己與 root 才有權力刪除該檔案</li>
		</ul>

		<p>換句話說：當甲這個使用者於 A 目錄是具有群組或其他人的身份，並且擁有該目錄 w 的權限，
		這表示『甲使用者對該目錄內任何人建立的目錄或檔案均可進行 "刪除/更名/搬移" 等動作。』
		不過，<span class="text_import2">如果將 A 目錄加上了 SBIT 的權限項目時，
		則甲只能夠針對自己建立的檔案或目錄進行刪除/更名/移動等動作，而無法刪除他人的檔案。</span></p>

		<p>舉例來說，我們的 /tmp 本身的權限是『drwxrwxrwt』，
		在這樣的權限內容下，任何人都可以在 /tmp 內新增、修改檔案，但僅有該檔案/目錄建立者與 root 
		能夠刪除自己的目錄或檔案。這個特性也是挺重要的啊！你可以這樣做個簡單的測試：</p>

		<ol>
		<li>以 root 登入系統，並且進入 /tmp 當中；</li>
		<li>touch test，並且更改 test 權限成為 777 ；</li>
		<li>以一般使用者登入，並進入 /tmp；</li>
		<li>嘗試刪除 test 這個檔案！</li></ol>

		<p>由於 SUID/SGID/SBIT 牽涉到程序的概念，因此再次強調，這部份的資料在您讀完<a 
		href="0440processcontrol.php">第十七章關於程序方面</a>的知識後，要再次的回來瞧瞧喔！
		目前，你先有個簡單的基礎概念就好了！文末的參考資料也建議閱讀一番喔！<br /><br /></p>

		<a name="suid_set"></a>
		<hr /><ul class="list1"><li class="text_import1">SUID/SGID/SBIT 權限設定</li></ul>
		<p>前面介紹過 SUID 與 SGID 的功能，那麼如何設定檔案使成為具有 SUID 與 SGID 的權限呢？
		這就需要<a href="/linux_basic/0210filepermission.php">第六章的數字更改權限</a>的方法了！
		現在你應該已經知道數字型態更改權限的方式為『三個數字』的組合，
		那麼如果在這三個數字之前再加上一個數字的話，最前面的那個數字就代表這幾個權限了！</p>
		<ul class="text_import2">
		<li>4 為 SUID</li>
		<li>2 為 SGID</li>

		<li>1 為 SBIT</li></ul>
		<p>假設要將一個檔案權限改為『-rwsr-xr-x』時，由於 s 在使用者權限中，所以是 SUID ，因此，
		在原先的 755 之前還要加上 4 ，也就是：『 chmod 4755 filename 』來設定！此外，還有大 S 與大 
		T 的產生喔！參考底下的範例啦！</p>
		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tr><td><b>Tips:</b><br /><span style="color : #009000"><font size="-1">		注意：底下的範例只是練習而已，所以鳥哥使用同一個檔案來設定，你必須瞭解
		SUID 不是用在目錄上，而 SBIT 不是用在檔案上的喔！
		</font></span></td><td><img src="/images/vbird_face.gif" alt="鳥哥的圖示" title="鳥哥的圖示" /></td></tr></table></div>
<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">cd /tmp</span>
[root@www tmp]# <span class="term_command">touch test                 </span> <span class="term_note">&lt;==建立一個測試用空檔</span>

[root@www tmp]# <span class="term_command">chmod 4755 test; ls -l test</span> <span class="term_note">&lt;==加入具有 SUID 的權限</span>
-rw<span class="term_write">s</span>r-xr-x 1 root root 0 Sep 29 03:06 test
[root@www tmp]# <span class="term_command">chmod 6755 test; ls -l test</span> <span class="term_note">&lt;==加入具有 SUID/SGID 的權限</span>
-rw<span class="term_write">s</span>r-<span class="term_write">s</span>r-x 1 root root 0 Sep 29 03:06 test
[root@www tmp]# <span class="term_command">chmod 1755 test; ls -l test</span> <span class="term_note">&lt;==加入 SBIT 的功能！</span>

-rwxr-xr-<span class="term_write">t</span> 1 root root 0 Sep 29 03:06 test
[root@www tmp]# <span class="term_command">chmod 7666 test; ls -l test</span> <span class="term_note">&lt;==具有空的 SUID/SGID 權限</span>
-rw<span class="term_write">S</span>rw<span class="term_write">S</span>rw<span class="term_write">T</span> 1 root root 0 Sep 29 03:06 test
</pre></td></tr></table>

		<p>最後一個例子就要特別小心啦！怎麼會出現大寫的 S 與 T 呢？不都是小寫的嗎？
		因為 s 與 t 都是取代 x 這個權限的，但是你有沒有發現阿，我們是下達 7666 喔！也就是說， 
		<span class="text_import2">user, group 以及 others 都沒有 x 這個可執行的標誌( 因為 666 嘛 )，所以，這個 S, 
		T 代表的就是『空的』啦</span>！怎麼說？ SUID 是表示『該檔案在執行的時候，具有檔案擁有者的權限』，但是檔案
		擁有者都無法執行了，哪裡來的權限給其他人使用？當然就是空的啦！ ^_^</p>

		<p>而除了數字法之外，妳也可以透過符號法來處理喔！其中 SUID 為 u+s ，而 SGID 為 g+s ，SBIT
		則是 o+t 囉！來看看如下的範例：</p>

<table class="term"><tr><td class="term"><pre>
<span class="term_hd"># 設定權限成為 -rws--x--x 的模樣：</span>
[root@www tmp]# <span class="term_command">chmod u=rwxs,go=x test; ls -l test</span>

-rw<span class="term_write">s</span>--x--x 1 root root 0 Aug 18 23:47 test

<span class="term_hd"># 承上，加上 SGID 與 SBIT 在上述的檔案權限中！</span>
[root@www tmp]# <span class="term_command">chmod g+s,o+t test; ls -l test</span>
-rws--s--t 1 root root 0 Aug 18 23:47 test
</pre></td></tr></table>

	</div>

	<hr /><a name="file"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">觀察檔案類型：file</span><br />

	<div class="block2">
		<p>如果你想要知道某個檔案的基本資料，例如是屬於 ASCII 或者是 data 檔案，或者是 binary ，
		且其中有沒有使用到動態函式庫 (share library) 等等的資訊，就可以利用 file 這個指令來檢閱喔！
		舉例來說：</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">file ~/.bashrc</span>
/root/.bashrc: ASCII text  <span class="term_note">&lt;==告訴我們是 ASCII 的純文字檔啊！</span>
[root@www ~]# <span class="term_command">file /usr/bin/passwd</span>
/usr/bin/passwd: setuid ELF 32-bit LSB executable, Intel 80386, version 1 
(SYSV), for GNU/Linux 2.6.9, dynamically linked (uses shared libs), for 
GNU/Linux 2.6.9, stripped

<span class="term_say"># 執行檔的資料可就多的不得了！包括這個檔案的 suid 權限、相容於 Intel 386
# 等級的硬體平台、使用的是 Linux 核心 2.6.9 的動態函式庫連結等等。</span>
[root@www ~]# <span class="term_command">file /var/lib/mlocate/mlocate.db</span>
/var/lib/mlocate/mlocate.db: data  <span class="term_note">&lt;== 這是 data 檔案！</span>
</pre></td></tr></table>

		<p>透過這個指令，我們可以簡單的先判斷這個檔案的格式為何喔！</p>
	</div>
</div>

<hr /><a name="file_find"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">指令與檔案的搜尋：</span><br />
<div class="block1">
	<p>檔案的搜尋可就厲害了！因為我們常常需要知道那個檔案放在哪裡，才能夠對該檔案進行一些修改或維護等動作。
	有些時候某些軟體設定檔的檔名是不變的，但是各 distribution 放置的目錄則不同。
	此時就得要利用一些搜尋指令將該設定檔的完整檔名捉出來，這樣才能修改嘛！您說是吧！^_^<br /><br /></p>

	<hr /><a name="file_find_cmd"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">指令檔名的搜尋：</span><br />
	<div class="block2">
		<p>我們知道在終端機模式當中，連續輸入兩次[tab]按鍵就能夠知道使用者有多少指令可以下達。
		那你知不知道這些指令的完整檔名放在哪裡？舉例來說，ls 這個常用的指令放在哪裡呢？
		就透過 which 或 type 來找尋吧！<br /><br /></p>

		<a name="which"></a>
		<hr /><ul class="list1"><li class="text_import1">which (尋找『執行檔』)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">which [-a] command</span>
<span class="term_say">選項或參數：
-a ：將所有由 PATH 目錄中可以找到的指令均列出，而不止第一個被找到的指令名稱</span>

<span class="term_hd">範例一：分別用root與一般帳號搜尋 ifconfig 這個指令的完整檔名</span>
[root@www ~]# <span class="term_command">which ifconfig</span>

/sbin/ifconfig            <span class="term_note">&lt;==用 root 可以找到正確的執行檔名喔！</span>
[root@www ~]# <span class="term_command">su - vbird</span> <span class="term_note">&lt;==切換身份成為 vbird 去！</span>
[vbird@www ~]$ <span class="term_command">which ifconfig</span>
/usr/bin/which: no ifconfig in (/usr/kerberos/bin:/usr/local/bin:/bin:/usr/bin
:/home/vbird/bin)         <span class="term_note">&lt;==見鬼了！竟然一般身份帳號找不到！</span>
<span class="term_say"># 因為 which 是根據使用者所設定的 PATH 變數內的目錄去搜尋可執行檔的！所以，
# 不同的 PATH 設定內容所找到的指令當然不一樣啦！因為 /sbin 不在 vbird 的 
# PATH 中，找不到也是理所當然的啊！瞭乎？</span>
[vbird@www ~]$ <span class="term_command">exit</span>      <span class="term_note">&lt;==記得將身份切換回原本的 root</span>

<span class="term_hd">範例二：用 which 去找出 which 的檔名為何？</span>
[root@www ~]# <span class="term_command">which which</span>
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot '
        /usr/bin/which
<span class="term_say"># 竟然會有兩個 which ，其中一個是 alias 這玩意兒呢！那是啥？
# 那就是所謂的『命令別名』，意思是輸入 which 會等於後面接的那串指令啦！
# 更多的資料我們會在 bash 章節中再來談的！</span>

<span class="term_hd">範例三：請找出 cd 這個指令的完整檔名</span>
[root@www ~]# <span class="term_command">which cd</span>
/usr/bin/which: no cd in (/usr/kerberos/sbin:/usr/kerberos/bin:/usr/local/sbin
:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin)
<span class="term_say"># 瞎密？怎麼可能沒有 cd ，我明明就能夠用 root 執行 cd 的啊！</span>

</pre></td></tr></table>

		<p>這個指令是根據『<a href="#dir_path">PATH</a>』這個環境變數所規範的路徑，去搜尋『執行檔』的檔名～
		所以，重點是找出『執行檔』而已！且 which 後面接的是『完整檔名』喔！若加上 -a
		選項，則可以列出所有的可以找到的同名執行檔，而非僅顯示第一個而已！</p>

		<p>最後一個範例最有趣，怎麼 cd 這個常用的指令竟然找不到啊！為什麼呢？這是因為 cd 是『bash 內建的指令』啦！
		但是 which 預設是找 PATH 內所規範的目錄，所以當然一定找不到的啊！那怎辦？沒關係！我們可以透過 type 這個指令喔！
		關於 type 的用法我們將在 <a href="/linux_basic/0320bash.php#bash_type">第十一章的 bash</a> 再來談！</p>
	</div>

	<hr /><a name="file_find_file"></a><img src="/images/penguin-s.gif" alt="小標題的圖示" height="23" width="16" align="middle" /><span class="text_h2">檔案檔名的搜尋：</span><br />
	<div class="block2">
		<p>再來談一談怎麼搜尋檔案吧！在 Linux 底下也有相當優異的搜尋指令呦！通常 find 不很常用的！因為速度慢之外，
		也很操硬碟！通常我們都是先使用 whereis 或者是 locate 來檢查，如果真的找不到了，才以 find 來搜尋呦！
		為什麼呢？因為 whereis 與 locate 是利用資料庫來搜尋資料，所以相當的快速，而且並沒有實際的搜尋硬碟，
		比較省時間啦！<br /><br /></p>

		<a name="whereis"></a>
		<hr /><ul class="list1"><li class="text_import1">whereis (尋找特定檔案)</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">whereis [-bmsu] 檔案或目錄名</span>

<span class="term_say">選項與參數：
-b    :只找 binary 格式的檔案
-m    :只找在說明檔 manual 路徑下的檔案
-s    :只找 source 來源檔案
-u    :搜尋不在上述三個項目當中的其他特殊檔案</span>

<span class="term_hd">範例一：請用不同的身份找出 ifconfig 這個檔名</span>
[root@www ~]# <span class="term_command">whereis ifconfig </span>
ifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz
[root@www ~]# <span class="term_command">su - vbird       </span> <span class="term_note">&lt;==切換身份成為 vbird</span>
[vbird@www ~]$ <span class="term_command">whereis ifconfig</span> <span class="term_note">&lt;==找到同樣的結果喔！</span>

ifconfig: /sbin/ifconfig /usr/share/man/man8/ifconfig.8.gz
[vbird@www ~]$ <span class="term_command">exit             </span> <span class="term_note">&lt;==回歸身份成為 root 去！</span>
<span class="term_say"># 注意看，明明 which 一般使用者找不到的 ifconfig 卻可以讓 whereis 找到！
# 這是因為系統真的有 ifconfig 這個『檔案』，但是使用者的 PATH 並沒有加入 /sbin
# 所以，未來你找不到某些指令時，先用檔案搜尋指令找找看再說！</span>

<span class="term_hd">範例二：只找出跟 passwd 有關的『說明文件』檔名(man page)</span>
[root@www ~]# <span class="term_command">whereis -m passwd</span>
passwd: /usr/share/man/man1/passwd.1.gz /usr/share/man/man5/passwd.5.gz
</pre></td></tr></table>

		<p>等一下我們會提到 find 這個搜尋指令， find 是很強大的搜尋指令，但時間花用的很大！
		(因為 find 是直接搜尋硬碟，為如果你的硬碟比較老舊的話，嘿嘿！有的等！) 
		這個時候 whereis 就相當的好用了！另外， whereis 可以加入選項來找尋相關的資料，
		例如如果你是要找可執行檔( binary )那麼加上 -b 就可以啦！
		如果不加任何選項的話，那麼就將所有的資料列出來囉！</p>

		<p>那麼 whereis 到底是使用什麼咚咚呢？為何搜尋的速度會比 find 快這麼多？
		其實那也沒有什麼！這是因為 Linux 系統會將系統內的所有檔案都記錄在一個資料庫檔案裡面，
		而當使用 whereis 或者是底下要說的 locate 時，都會以此資料庫檔案的內容為準，
		因此，有的時後你還會發現使用這兩個執行檔時，會找到已經被殺掉的檔案！
		而且也找不到最新的剛剛建立的檔案呢！這就是因為這兩個指令是由資料庫當中的結果去搜尋檔案的所在啊！
		更多與這個資料庫有關的說明，請參考下列的 locate 指令。<br /><br /></p>

		<a name="locate"></a>
		<hr /><ul class="list1"><li class="text_import1">locate</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">locate [-ir] keyword</span>
<span class="term_say">選項與參數：
-i  ：忽略大小寫的差異；
-r  ：後面可接正規表示法的顯示方式</span>

<span class="term_hd">範例一：找出系統中所有與 passwd 相關的檔名</span>
[root@www ~]# <span class="term_command">locate passwd</span>
/etc/passwd
/etc/passwd-
/etc/news/passwd.nntp
/etc/pam.d/passwd
<span class="term_say">....(底下省略)....</span>
</pre></td></tr></table>

		<p>這個 locate 的使用更簡單，直接在後面輸入『檔案的部分名稱』後，就能夠得到結果。
		舉上面的例子來說，我輸入 locate passwd ，那麼在完整檔名 (包含路徑名稱) 當中，只要有 passwd 在其中，
		就會被顯示出來的！這也是個很方便好用的指令，如果你忘記某個檔案的完整檔名時～～</p>

		<p>但是，這個東西還是有使用上的限制呦！為什麼呢？你會發現使用 locate 來尋找資料的時候特別的快，
		這是因為 locate 尋找的資料是由『<span class="text_import2">已建立的資料庫 /var/lib/mlocate/</span>』
		裡面的資料所搜尋到的，所以不用直接在去硬碟當中存取資料，呵呵！當然是很快速囉！</p>

		<p>那麼有什麼限制呢？就是因為他是經由資料庫來搜尋的，而資料庫的建立預設是在每天執行一次
		(每個 distribution 都不同，CentOS 5.x 是每天更新資料庫一次！)，所以當你新建立起來的檔案，
		卻還在資料庫更新之前搜尋該檔案，那麼 locate 會告訴你『找不到！』呵呵！因為必須要更新資料庫呀！</p>

		<a name="updatedb"></a>
		<p>那能否手動更新資料庫哪？當然可以啊！更新 locate 資料庫的方法非常簡單，直接輸入『 updatedb 』就可以了！
		updatedb 指令會去讀取 /etc/updatedb.conf 這個設定檔的設定，然後再去硬碟裡面進行搜尋檔名的動作，
		最後就更新整個資料庫檔案囉！因為 updatedb 會去搜尋硬碟，所以當你執行 updatedb 時，可能會等待數分鐘的時間喔！</p>
		<ul class="text_import2">
		<li>updatedb：根據 /etc/updatedb.conf 的設定去搜尋系統硬碟內的檔名，並更新 /var/lib/mlocate 內的資料庫檔案；</li>
		<li>locate：依據 /var/lib/mlocate 內的資料庫記載，找出使用者輸入的關鍵字檔名。</li></ul><br />

		<a name="find"></a>
		<hr /><ul class="list1"><li class="text_import1">find</li></ul>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">find [PATH] [option] [action]</span>
<span class="term_say">選項與參數：
1. 與時間有關的選項：共有 -atime, -ctime 與 -mtime ，以 -mtime 說明
   -mtime  n ：n 為數字，意義為在 n 天之前的『一天之內』被更動過內容的檔案；
   -mtime +n ：列出在 n 天之前(不含 n 天本身)被更動過內容的檔案檔名；
   -mtime -n ：列出在 n 天之內(含 n 天本身)被更動過內容的檔案檔名。
   -newer file ：file 為一個存在的檔案，列出比 file 還要新的檔案檔名</span>

<span class="term_hd">範例一：將過去系統上面 24 小時內有更動過內容 (mtime) 的檔案列出</span>
[root@www ~]# <span class="term_command">find / -mtime 0</span>

<span class="term_say"># 那個 0 是重點！0 代表目前的時間，所以，從現在開始到 24 小時前，
# 有變動過內容的檔案都會被列出來！那如果是三天前的 24 小時內？
# find / -mtime 3 有變動過的檔案都被列出的意思！</span>

<span class="term_hd">範例二：尋找 /etc 底下的檔案，如果檔案日期比 /etc/passwd 新就列出</span>
[root@www ~]# <span class="term_command">find /etc -newer /etc/passwd</span>
<span class="term_say"># -newer 用在分辨兩個檔案之間的新舊關係是很有用的！</span>
</pre></td></tr></table>

		<p>時間參數真是挺有意思的！我們現在知道 atime, ctime 與 mtime 的意義，如果你想要找出一天內被更動過的檔案名稱，
		可以使用上述範例一的作法。但如果我想要找出『4天內被更動過的檔案檔名』呢？那可以使用『
		<span class="text_import2">find /var -mtime -4</span> 』。那如果是『4天前的那一天』就用『
		<span class="text_import2">find /var -mtime 4</span> 』。有沒有加上『+, 
		-』差別很大喔！我們可以用簡單的圖示來說明一下：</p>

		<center><img src="0220filemanager/find_time.gif" alt="find 相關的時間參數意義" 
		title="find 相關的時間參數意義" border="1" /><br />
		圖5.2.1、find 相關的時間參數意義<br /></center>

		<p>圖中最右邊為目前的時間，越往左邊則代表越早之前的時間軸啦。由圖5.2.1我們可以清楚的知道：</p>
		<ul class="text_import2">
		<li>+4代表大於等於5天前的檔名：ex&gt; find /var -mtime +4</li>

		<li>-4代表小於等於4天內的檔案檔名：ex&gt; find /var -mtime -4</li>
		<li> 4則是代表4-5那一天的檔案檔名：ex&gt; find /var -mtime 4</li></ul>

		<p>非常有趣吧！你可以在 /var/ 目錄下搜尋一下，感受一下輸出檔案的差異喔！再來看看其他 find 的用法吧！</p>

<table class="term"><tr><td class="term"><pre>

<span class="term_say">選項與參數：
2. 與使用者或群組名稱有關的參數：
   -uid n ：n 為數字，這個數字是使用者的帳號 ID，亦即 UID ，這個 UID 是記錄在
            /etc/passwd 裡面與帳號名稱對應的數字。這方面我們會在第四篇介紹。
   -gid n ：n 為數字，這個數字是群組名稱的 ID，亦即 GID，這個 GID 記錄在
            /etc/group，相關的介紹我們會第四篇說明～
   -user name ：name 為使用者帳號名稱喔！例如 dmtsai 
   -group name：name 為群組名稱喔，例如 users ；
   -nouser    ：尋找檔案的擁有者不存在 /etc/passwd 的人！
   -nogroup   ：尋找檔案的擁有群組不存在於 /etc/group 的檔案！
                當你自行安裝軟體時，很可能該軟體的屬性當中並沒有檔案擁有者，
                這是可能的！在這個時候，就可以使用 -nouser 與 -nogroup 搜尋。</span>

<span class="term_hd">範例三：搜尋 /home 底下屬於 vbird 的檔案</span>
[root@www ~]# <span class="term_command">find /home -user vbird</span>
<span class="term_say"># 這個東西也很有用的～當我們要找出任何一個使用者在系統當中的所有檔案時，
# 就可以利用這個指令將屬於某個使用者的所有檔案都找出來喔！</span>

<span class="term_hd">範例四：搜尋系統中不屬於任何人的檔案</span>
[root@www ~]# <span class="term_command">find / -nouser</span>
<span class="term_say"># 透過這個指令，可以輕易的就找出那些不太正常的檔案。
# 如果有找到不屬於系統任何人的檔案時，不要太緊張，
# 那有時候是正常的～尤其是你曾經以原始碼自行編譯軟體時。</span>

</pre></td></tr></table>

		<p>如果你想要找出某個使用者在系統底下建立了啥咚咚，使用上述的選項與參數，就能夠找出來啦！
		至於那個 -nouser 或 -nogroup 的選項功能中，除了你自行由網路上面下載檔案時會發生之外，
		如果你將系統裡面某個帳號刪除了，但是該帳號已經在系統內建立很多檔案時，就可能會發生無主孤魂的檔案存在！
		此時你就得使用這個 -nouser  來找出該類型的檔案囉！</p>

<table class="term"><tr><td class="term"><pre>
<span class="term_say">選項與參數：
3. 與檔案權限及名稱有關的參數：
   -name filename：搜尋檔案名稱為 filename 的檔案；
   -size [+-]SIZE：搜尋比 SIZE 還要大(+)或小(-)的檔案。這個 SIZE 的規格有：
                   c: 代表 byte， k: 代表 1024bytes。所以，要找比 50KB
                   還要大的檔案，就是『 -size +50k 』
   -type TYPE    ：搜尋檔案的類型為 TYPE 的，類型主要有：一般正規檔案 (f),
                   裝置檔案 (b, c), 目錄 (d), 連結檔 (l), socket (s), 
                   及 FIFO (p) 等屬性。
   -perm mode  ：搜尋檔案權限『剛好等於』 mode 的檔案，這個 mode 為類似 chmod
                 的屬性值，舉例來說， -rwsr-xr-x 的屬性為 4755 ！
   -perm -mode ：搜尋檔案權限『必須要全部囊括 mode 的權限』的檔案，舉例來說，
                 我們要搜尋 -rwxr--r-- ，亦即 0744 的檔案，使用 -perm -0744，
                 當一個檔案的權限為 -rwsr-xr-x ，亦即 4755 時，也會被列出來，
                 因為 -rwsr-xr-x 的屬性已經囊括了 -rwxr--r-- 的屬性了。
   -perm +mode ：搜尋檔案權限『包含任一 mode 的權限』的檔案，舉例來說，我們搜尋
                 -rwxr-xr-x ，亦即 -perm +755 時，但一個檔案屬性為 -rw-------
                 也會被列出來，因為他有 -rw.... 的屬性存在！</span>

<span class="term_hd">範例五：找出檔名為 passwd 這個檔案</span>
[root@www ~]# <span class="term_command">find / -name passwd</span>
<span class="term_say"># 利用這個 -name 可以搜尋檔名啊！</span>

<span class="term_hd">範例六：找出 /var 目錄下，檔案類型為 Socket 的檔名有哪些？</span>
[root@www ~]# <span class="term_command">find /var -type s</span>
<span class="term_say"># 這個 -type 的屬性也很有幫助喔！尤其是要找出那些怪異的檔案，
# 例如 socket 與 FIFO 檔案，可以用 find /var -type p 或 -type s 來找！</span>

<span class="term_hd">範例七：搜尋檔案當中含有 SGID 或 SUID 或 SBIT 的屬性</span>
[root@www ~]# <span class="term_command">find / -perm +7000 </span>
<span class="term_say"># 所謂的 7000 就是 ---s--s--t ，那麼只要含有 s 或 t 的就列出，
# 所以當然要使用 +7000 ，使用 -7000 表示要含有 ---s--s--t 的所有三個權限，
# 因此，就是 +7000 ～瞭乎？</span>
</pre></td></tr></table>

		<p>上述範例中比較有趣的就屬 -perm 這個選項啦！他的重點在找出特殊權限的檔案囉！
		我們知道 SUID 與 SGID 都可以設定在二進位程式上，假設我想要找出來 /bin, /sbin 這兩個目錄下，
		只要具有 SUID 或 SGID 就列出來該檔案，你可以這樣做：</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">find /bin /sbin -perm +6000</span>
</pre></td></tr></table>

		<p>因為 SUID 是 4 分，SGID 2 分，總共為 6 分，因此可用 +6000 來處理這個權限！
		至於 find 後面可以接多個目錄來進行搜尋！另外， <span 
		class="text_import2">find 本來就會搜尋次目錄</span>，這個特色也要特別注意喔！
		最後，我們再來看一下 find 還有什麼特殊功能吧！</p>

<table class="term"><tr><td class="term"><pre>
<span class="term_say">選項與參數：
4. 額外可進行的動作：
   -exec command ：command 為其他指令，-exec 後面可再接額外的指令來處理搜尋到
                   的結果。
   -print        ：將結果列印到螢幕上，這個動作是預設動作！</span>

<span class="term_hd">範例八：將上個範例找到的檔案使用 ls -l 列出來～</span>
[root@www ~]# <span class="term_command">find / -perm +7000 -exec ls -l {} \;</span>
<span class="term_say"># 注意到，那個 -exec 後面的 ls -l 就是額外的指令，指令不支援命令別名，
# 所以僅能使用 ls -l 不可以使用 ll 喔！注意注意！</span>

<span class="term_hd">範例九：找出系統中，大於 1MB 的檔案</span>
[root@www ~]# <span class="term_command">find / -size +1000k</span>

<span class="term_say"># 雖然在 man page 提到可以使用 M 與 G 分別代表 MB 與 GB，
# 不過，俺卻試不出來這個功能～所以，目前應該是僅支援到 c 與 k 吧！</span>
</pre></td></tr></table>

		<p>find 的特殊功能就是能夠進行額外的動作(action)。我們將範例八的例子以圖解來說明如下：</p>

		<center><img src="0220filemanager/find_exec.gif" alt="find 相關的額外動作" 
		title="find 相關的額外動作" border="0" /><br />
		圖5.2.2、find 相關的額外動作<br /></center>

		<p>該範例中特殊的地方有 {} 以及 \; 還有 -exec 這個關鍵字，這些東西的意義為：</p>

		<ul class="text_import2">
		<li>{} 代表的是『由 find 找到的內容』，如上圖所示，find 的結果會被放置到 {} 位置中；</li>
		<li>-exec 一直到  \; 是關鍵字，代表 find 額外動作的開始 (-exec) 到結束 (\;) ，在這中間的就是 find 指令內的額外動作。
		在本例中就是『 ls -l {} 』囉！</li>
		<li>因為『 ; 』在 bash 環境下是有特殊意義的，因此利用反斜線來跳脫。</li></ul>

		<p>透過圖 5.2.2 你應該就比較容易瞭解 -exec 到 \; 之間的意義了吧！</p>

		<p>如果你要找的檔案是具有特殊屬性的，例如 SUID 、檔案擁有者、檔案大小等等，
		那麼利用 locate 是沒有辦法達成你的搜尋的！此時 find 就顯的很重要啦！
		另外，find 還可以利用萬用字元來找尋檔名呢！舉例來說，你想要找出 /etc 底下檔名包含 httpd 的檔案，
		那麼你就可以這樣做：</p>

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">find /etc -name '*httpd*'</span>
</pre></td></tr></table>

		<p>不但可以指定搜尋的目錄(連同次目錄)，並且可以利用額外的選項與參數來找到最正確的檔名！真是好好用！
		不過由於 find 在尋找資料的時後相當的操硬碟！所以沒事情不要使用 find 啦！有更棒的指令可以取代呦！那就是上面提到的
		<a href="#whereis">whereis</a> 與 <a href="#locate">locate</a> 囉！</p>
	</div>

</div>


<hr /><a name="import"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">極重要！權限與指令間的關係：</span><br />
<div class="block1">
	<p>我們知道權限對於使用者帳號來說是非常重要的，因為他可以限制使用者能不能讀取/建立/刪除/修改檔案或目錄！
	在這一章我們介紹了很多檔案系統的管理指令，第六章則介紹了很多檔案權限的意義。在這個小節當中，
	我們就將這兩者結合起來，說明一下什麼指令在什麼樣的權限下才能夠運作吧！^_^</p>

	<p>一、讓使用者能進入某目錄成為『可工作目錄』的基本權限為何：</p>
	<ul>
		<li>可使用的指令：例如 cd 等變換工作目錄的指令；</li>

		<li>目錄所需權限：<span class="text_import2">使用者對這個目錄至少需要具有 x 的權限</span></li>
		<li>額外需求：如果使用者想要在這個目錄內利用 ls 查閱檔名，則使用者對此目錄還需要 r 的權限。</li></ul>

	<p>二、使用者在某個目錄內讀取一個檔案的基本權限為何？</p>
	<ul>
		<li>可使用的指令：例如本章談到的 cat, more, less等等</li>
		<li>目錄所需權限：使用者對這個目錄至少需要具有 x 權限；</li>

		<li>檔案所需權限：<span class="text_import2">使用者對檔案至少需要具有 r 的權限才行！</span></li></ul>

	<p>三、讓使用者可以修改一個檔案的基本權限為何？</p>
	<ul>
		<li>可使用的指令：例如 <a href="/linux_basic/0160startlinux.php#nano">nano</a> 或未來要介紹的 <a
		href="/linux_basic/0310vi.php">vi</a> 編輯器等；</li>

		<li>目錄所需權限：使用者在該檔案所在的目錄至少要有 x 權限；</li>
		<li>檔案所需權限：<span class="text_import2">使用者對該檔案至少要有 r, w 權限</span></li></ul>

	<p>四、讓一個使用者可以建立一個檔案的基本權限為何？</p>
	<ul>
		<li>目錄所需權限：<span class="text_import2">使用者在該目錄要具有 w,x 的權限，重點在 w 啦！</span></li></ul>

	<p>五、讓使用者進入某目錄並執行該目錄下的某個指令之基本權限為何？</p>
	<ul>
		<li>目錄所需權限：使用者在該目錄至少要有 x 的權限；</li>
		<li>檔案所需權限：使用者在該檔案至少需要有 x 的權限</li></ul>

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">
讓一個使用者 vbird 能夠進行『cp /dir1/file1 /dir2』的指令時，請說明 dir1, file1, dir2 的最小所需權限為何？

</div>
答：<div class="block2">
執行 cp 時， vbird 要『能夠讀取來源檔，並且寫入目標檔！』所以應參考上述第二點與第四點的說明！
因此各檔案/目錄的最小權限應該是：
<ul style="font-family:'細明體'">
<li>dir1 ：至少需要有 x 權限；</li>
<li>file1：至少需要有 r 權限；</li>
<li>dir2 ：至少需要有 w, x 權限。</li></ul>
</div>
</td></tr></table><br />

<table border="1" width="90%" cellspacing="0" cellpadding="5"><tr><td>
例題：<div class="block2">

有一個檔案全名為 /home/student/www/index.html ，各相關檔案/目錄的權限如下：
<pre style="font-family:'細明體'; font-size: 10pt">
drwxr-xr-x 23 root    root    4096 Sep 22 12:09 /
drwxr-xr-x  6 root    root    4096 Sep 29 02:21 /home
drwx------  6 student student 4096 Sep 29 02:23 /home/student
drwxr-xr-x  6 student student 4096 Sep 29 02:24 /home/student/www
-rwxr--r--  6 student student  369 Sep 29 02:27 /home/student/www/index.html</pre>
請問 vbird 這個帳號(不屬於student群組)能否讀取 index.html 這個檔案呢？
</div>
答：<div class="block2">
雖然 www 與 index.html 是可以讓 vbird 讀取的權限，但是因為目錄結構是由根目錄一層一層讀取的，
因此 vbird 可進入 /home 但是卻不可進入 /home/student/ ，既然連進入 /home/student 都不許了，
當然就讀不到 index.html 了！所以答案是『vbird不會讀取到 index.html 的內容』喔！<br /><br />
那要如何修改權限呢？其實只要將 /home/student 的權限修改為最小 711 ，或者直接給予 755 就可以囉！
這可是很重要的概念喔！
</div>
</td></tr></table>
</div>


<hr /><a name="hint"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">重點回顧</span><br />

<div class="block1">
<ul class="text_import2">
	<li>絕對路徑：『一定由根目錄 / 寫起』；相對路徑：『不是由 / 寫起』</li>
	<li>特殊目錄有：., .., -, ~, ~account需要注意；</li>
	<li>與目錄相關的指令有：cd, mkdir, rmdir, pwd 等重要指令；</li>
	<li>rmdir 僅能刪除空目錄，要刪除非空目錄需使用『 rm -r 』指令；</li>
	<li>使用者能使用的指令是依據 PATH 變數所規定的目錄去搜尋的；</li>

	<li>不同的身份(root 與一般用戶)系統預設的 PATH 並不相同。差異較大的地方在於 /sbin, /usr/sbin ；</li>
	<li>ls 可以檢視檔案的屬性，尤其 -d, -a, -l 等選項特別重要！</li>
	<li>檔案的複製、刪除、移動可以分別使用：cp, rm , mv等指令來操作；</li>
	<li>檢查檔案的內容(讀檔)可使用的指令包括有：cat, tac, nl, more, less, head, tail, od 等</li>
	<li>cat -n 與 nl 均可顯示行號，但預設的情況下，空白行會不會編號並不相同；</li>
	<li>touch 的目的在修改檔案的時間參數，但亦可用來建立空檔案；</li>

	<li>一個檔案記錄的時間參數有三種，分別是 access time(atime), status time (ctime), 
		modification time(mtime)，ls 預設顯示的是 mtime。</li>
	<li>除了傳統的rwx權限之外，在Ext2/Ext3檔案系統中，還可以使用chattr與lsattr設定及觀察隱藏屬性。
		常見的包括只能新增資料的 +a 與完全不能更動檔案的 +i 屬性。</li>
	<li>新建檔案/目錄時，新檔案的預設權限使用 umask 來規範。預設目錄完全權限為drwxrwxrwx，
		檔案則為-rw-rw-rw-。</li>
	<li>檔案具有SUID的特殊權限時，代表當使用者執行此一binary程式時，在執行過程中使用者會暫時具有程式擁有者的權限</li>
	<li>目錄具有SGID的特殊權限時，代表使用者在這個目錄底下新建的檔案之群組都會與該目錄的群組名稱相同。</li>
	<li>目錄具有SBIT的特殊權限時，代表在該目錄下使用者建立的檔案只有自己與root能夠刪除！</li>

	<li>觀察檔案的類型可以使用 file 指令來觀察；</li>
	<li>搜尋指令的完整檔名可用 which 或 type ，這兩個指令都是透過 PATH 變數來搜尋檔名；</li>
	<li>搜尋檔案的完整檔名可以使用 whereis 或 locate  到資料庫檔案去搜尋，而不實際搜尋檔案系統；</li>
	<li>利用 find 可以加入許多選項來直接查詢檔案系統，以獲得自己想要知道的檔名。</li>
</ul>
</div>


<hr /><a name="ex"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">本章習題：</span><br />

( 要看答案請將滑鼠移動到『答：』底下的空白處，按下左鍵圈選空白處即可察看 )
<div class="block1">
<a name="situation1"></a><hr />
情境模擬題一：假設系統中有兩個帳號，分別是 alex 與 arod ，這兩個人除了自己群組之外還共同支援一個名為 project 
的群組。假設這兩個用戶需要共同擁有 /srv/ahome/ 目錄的開發權，且該目錄不許其他人進入查閱。
請問該目錄的權限設定應為何？請先以傳統權限說明，再以 SGID 的功能解析。<br />
<ul>
	<li>目標：瞭解到為何專案開發時，目錄最好需要設定 SGID 的權限！</li>
	<li>前提：多個帳號支援同一群組，且共同擁有目錄的使用權！</li>
	<li>需求：需要使用 root 的身份來進行 chmod, chgrp 等幫用戶設定好他們的開發環境才行！
	這也是管理員的重要任務之一！</li>

</ul>

	首先我們得要先製作出這兩個帳號的相關資料，帳號/群組的管理在後續我們會介紹，
	您這裡先照著底下的指令來製作即可：<br />

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">groupadd project       </span> <span class="term_note">&lt;==增加新的群組</span>
[root@www ~]# <span class="term_command">useradd -G project alex</span> <span class="term_note">&lt;==建立 alex 帳號，且支援 project</span>
[root@www ~]# <span class="term_command">useradd -G project arod</span> <span class="term_note">&lt;==建立 arod 帳號，且支援 project</span>

[root@www ~]# <span class="term_command">id alex                </span> <span class="term_note">&lt;==查閱 alex 帳號的屬性</span>
uid=501(alex) gid=502(alex) groups=502(alex),<span class="term_write">501(project)</span> <span class="term_note">&lt;==確實有支援！</span>
[root@www ~]# <span class="term_command">id arod</span>
uid=502(arod) gid=503(arod) groups=503(arod),<span class="term_write">501(project)</span>
</pre></td></tr></table>

	然後開始來解決我們所需要的環境吧！<br />
<ol>
	<li>首先建立所需要開發的專案目錄：<br />
<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">mkdir /srv/ahome</span>
[root@www ~]# <span class="term_command">ll -d /srv/ahome</span>
drwxr-xr-x 2 root root 4096 Sep 29 22:36 /srv/ahome
</pre></td></tr></table></li>

	<li>從上面的輸出結果可發現 alex 與 arod 都不能在該目錄內建立檔案，因此需要進行權限與屬性的修改。
		由於其他人均不可進入此目錄，因此該目錄的群組應為project，權限應為770才合理。<br />

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">chgrp project /srv/ahome</span>
[root@www ~]# <span class="term_command">chmod 770 /srv/ahome</span>
[root@www ~]# <span class="term_command">ll -d /srv/ahome</span>
drwx<span class="term_write">rwx</span>--- 2 root <span class="term_write">project</span> 4096 Sep 29 22:36 /srv/ahome

<span class="term_say"># 從上面的權限結果來看，由於 alex/arod 均支援 project，因此似乎沒問題了！</span>
</pre></td></tr></table></li>

	<li>實際分別以兩個使用者來測試看看，情況會是如何？先用 alex 建立檔案，然後用 arod 去處理看看。<br />

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">su - alex      </span> <span class="term_note">&lt;==先切換身份成為 alex 來處理</span>
[alex@www ~]$ <span class="term_command">cd /srv/ahome  </span> <span class="term_note">&lt;==切換到群組的工作目錄去</span>

[alex@www ahome]$ <span class="term_command">touch abcd </span> <span class="term_note">&lt;==建立一個空的檔案出來！</span>
[alex@www ahome]$ <span class="term_command">exit       </span> <span class="term_note">&lt;==離開 alex 的身份</span>

[root@www ~]# <span class="term_command">su - arod</span>
[arod@www ~]$ <span class="term_command">cd /srv/ahome</span>

[arod@www ahome]$ <span class="term_command">ll abcd</span>
-rw-rw-r-- 1 alex <span class="term_write">alex</span> 0 Sep 29 22:46 abcd
<span class="term_say"># 仔細看一下上面的檔案，由於群組是 alex ，arod並不支援！
# 因此對於 abcd 這個檔案來說， arod 應該只是其他人，只有 r 的權限而已啊！</span>
[arod@www ahome]$ <span class="term_command">exit</span>
</pre></td></tr></table>
	由上面的結果我們可以知道，若單純使用傳統的 rwx 而已，則對剛剛 alex 建立的 abcd 這個檔案來說，
	<span class="text_import2">arod 可以刪除他，但是卻不能編輯他！</span>這不是我們要的樣子啊！趕緊來重新規劃一下。<br /><br /></li>

	<li>加入 SGID 的權限在裡面，並進行測試看看：<br />

<table class="term"><tr><td class="term"><pre>
[root@www ~]# <span class="term_command">chmod 2770 /srv/ahome</span>
[root@www ~]# <span class="term_command">ll -d /srv/ahome</span>
drwxrws--- 2 root project 4096 Sep 29 22:46 /srv/ahome

<span class="term_hd">測試：使用 alex 去建立一個檔案，並且查閱檔案權限看看：</span>
[root@www ~]# <span class="term_command">su - alex</span>

[alex@www ~]$ <span class="term_command">cd /srv/ahome</span>
[alex@www ahome]$ <span class="term_command">touch 1234</span>
[alex@www ahome]$ <span class="term_command">ll 1234</span>
-rw-<span class="term_write">rw-</span>r-- 1 alex <span class="term_write">project</span> 0 Sep 29 22:53 1234
<span class="term_say"># 沒錯！這才是我們要的樣子！現在 alex, arod 建立的新檔案所屬群組都是 project，
# 由於兩人均屬於此群組，加上 umask 都是 002，這樣兩人才可以互相修改對方的檔案！</span>

</pre></td></tr></table>
	所以最終的結果顯示，此目錄的權限最好是『2770』，所屬檔案擁有者屬於root即可，至於群組必須要為兩人共同支援的project
	這個群組才行！</li>
</ol>

<hr />簡答題部分：
<ul>
	<li>什麼是絕對路徑與相對路徑
	<div class="blockex">
		絕對路徑的寫法為由 / 開始寫，至於相對路徑則不由 / 開始寫！此外，相對路徑為相對於目前工作目錄的路徑！
	</div></li>

	<li>如何更改一個目錄的名稱？例如由 /home/test 變為 /home/test2
	<div class="blockex">

		mv /home/test /home/test2
	</div></li>

	<li>PATH 這個環境變數的意義？
	<div class="blockex">
		這個是用來指定執行檔執行的時候，指令搜尋的目錄路徑。
	</div></li>

	<li>umask 有什麼用處與優點？
	<div class="blockex">
		umask 可以拿掉一些權限，因此，適當的定義 umask 有助於系統的安全，
		因為他可以用來建立預設的目錄或檔案的權限。
	</div></li>

	<li>當一個使用者的 umask 分別為 033 與 044 他所建立的檔案與目錄的權限為何？
	<div class="blockex">
		在 umask 為 033 時，則預設是拿掉 group 與 other 的 w(2)x(1) 

		權限，因此權限就成為『檔案 -rw-r--r-- ， 目錄 drwxr--r-- 』而當
		umask 044 時，則拿掉 r 的屬性，因此就成為『檔案 -rw--w--w-，目錄 drwx-wx-wx』
	</div></li>

	<li>什麼是 SUID ？
	<div class="blockex">
		當一個指令具有 SUID 的功能時，則：
                <ul>
                <li>SUID 權限僅對二進位程式(binary program)有效；</li>

                <li>執行者對於該程式需要具有 x  的可執行權限；</li>
                <li>本權限僅在執行該程式的過程中有效 (run-time)；</li>
                <li>執行者將具有該程式擁有者 (owner) 的權限。</li>
                </ul>
	</div></li>

	<li>當我要查詢 /usr/bin/passwd 這個檔案的一些屬性時(1)傳統權限；(2)檔案類型與(3)檔案的隱藏屬性，可以使用什麼指令來查詢？
	<div class="blockex">

		ls -al<br /> file<br /> lsattr
	</div></li>

	<li>嘗試用 find 找出目前 linux 系統中，所有具有 SUID 的檔案有哪些？
	<div class="blockex">
		find / -perm +4000 -print
	</div></li>

	<li>找出 /etc 底下，檔案大小介於 50K 到 60K 之間的檔案，並且將權限完整的列出 (ls -l)：
	<div class="blockex">

		find /etc -size +50k -a -size -60k -exec ls -l {} \;<br />
		注意到 -a ，那個 -a 是 and 的意思，為符合兩者才算成功
	</div></li>

	<li>找出 /etc 底下，檔案容量大於 50K 且檔案所屬人不是 root 的檔名，且將權限完整的列出 (ls -l)；
	<div class="blockex">
		find /etc -size +50k -a ! -user root -exec ls -ld {} \;<br />
		find /etc -size +50k -a ! -user root -type f -exec ls -l {} \;<br />
		上面兩式均可！注意到 ! ，那個 ! 代表的是反向選擇，亦即『不是後面的項目』之意！
	</div></li>

	<li>找出 /etc 底下，容量大於 1500K 以及容量等於 0 的檔案：
	<div class="blockex">
		find /etc -size +1500k -o -size 0<br />
		相對於 -a ，那個 -o 就是或 (or) 的意思囉！
	</div></li>

</ul>
</div>


<hr /><a name="reference"></a><img src="/images/penguin-m.gif" alt="大標題的圖示" height="34" width="25" align="middle" /><span class="text_h1">參考資料與延伸閱讀</span><br />

<div class="block1">
<ul>
	<li>小洲大大回答 SUID/SGID 的一篇討論：<br />
		<a href="http://phorum.vbird.org/viewtopic.php?t=20256"
		target="_blank">http://phorum.vbird.org/viewtopic.php?t=20256</a></li>
</ul>
</div>


<hr /><span class="text_history">
2002/06/26：第一次完成
2003/02/06：重新編排與加入 FAQ<br />
2003/02/07：加入 basename 與 dirname 的說明<br />

2004/03/15：將連結檔的內容移動至下一章節：<a href="0230filesystem.php" target="_self">Linux 磁碟與硬體管理</a><br />
2005/07/19：將舊的文章移動到 <a href="0220filemanager/0220filemanager.php">這裡</a> 了。<br />
2005/07/20：呼呼！好不容易啊～在被颱風尾掃到的七月份，終於寫完這個咚咚～<br />
2005/07/21：在 find 部分，多增加了範例九，以及關於利用檔案大小 (size) 搜尋的功能。<br />
2005/07/25：在 SUID/SGID/SBIT 部分，依據 netman 與 小州 兄的建議，修改了部分的敘述！<br />
2006/04/09：在 rmdir 的範例內，少了一個 -p 的參數！<br />
2006/06/15：經由討論區網友 dm421 的通知，發現 chattr 的部分關於 d 寫錯了，已訂正。<br />

2006/08/22：增加 rm 的一些簡單的說明！尤其是『 rm ./-aaa- 』的刪除方法！<br />
2008/09/23：將針對FC4版寫的資料移到<a href="0220filemanager/0220filemanager-fc4.php">此處</a><br />
2008/09/29：加入<a href="#import">權限與指令的關係</a>一節，並新增<a href="#situation1">情境模擬</a>題目喔！大家幫忙除錯一下！<br />
2009/08/18：加入符號法的方式來處理 SUID/SGID/SBIT 囉！<br />
2009/08/26：感謝網友告知習題部分，找出 /etc 底下容量大於 50k 的那題，應使用 -type f 或 ls -ld  來避免目錄內重複顯示！<br />
</span>
<hr />
<br />
    </td>
  <!-- InstanceEndEditable -->
  
  <td style="width:16px; font-size:6px;
	background-image:url('/images/border-middle-right.jpg')">　</td></tr>
<tr><td style="width:16px; height:16px; background-image:url('/images/border-bottom-left.jpg');
        font-size:6px">　</td>
    <td style="width:750px; height:16px; font-size:6px;
        background-image:url('/images/border-bottom-center.jpg')">　</td>

    <td style="width:16px; height:16px; background-image:url('/images/border-bottom-right.jpg');
        font-size:6px">　</td></tr>
</table>

<div style="padding-top:10px; text-align:center">
<span style="font-size: 80%">

	本網頁主要以 <a href="http://moztw.org" target="_blank">firefox</a> 配合解析度 1024x768 作為設計依據<br />
	<a href="http://linux.vbird.org" target="_top" title="前往鳥哥的首頁">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="聯絡鳥哥(我不要廣告信！)">VBird</a>
		during 2001-2009.
	<a href="http://aerosol.ev.ncku.edu.tw">Aerosol Lab.</a></span>
</div>
</center>
</body>
<!-- InstanceEnd --></html>
